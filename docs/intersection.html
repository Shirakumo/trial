<!DOCTYPE html><html><head><title>Trial / Intersection / Collision Testing</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Trial provides an array of intersection and collision testing functions. The functions to use are called intersects-p, detect-hits, and detect-hit."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Intersection / Collision Testing"><meta property="og:url" content="https://shirakumo.org/docs/trial/intersection.mess.html"><meta property="og:description" content="Trial provides an array of intersection and collision testing functions. The functions to use are called intersects-p, detect-hits, and detect-hit."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="intersection / collision testing">Intersection / Collision Testing</h1><p>Trial provides an array of intersection and collision testing functions. The functions to use are called <code>intersects-p</code>, <code>detect-hits</code>, and <code>detect-hit</code>.</p><p>The <code>intersects-p</code> test <em>may</em> be faster for some tests, as broader, more specialised tests can be implemented that are faster to execute. If there's no special implementation it falls back on <code>detect-hits</code>.</p><p>All of these functions operate on <code>primitive</code> objects or a <code>ray</code>. Primitives describe a particular shape with its centre at the origin and aligned along the axes. A transform matrix is used to handle translation and rotation of the shape.</p><p>When you access a primitive's <code>location</code> and <code>orientation</code>, it accesses the <code>primitive-local-transform</code> in the back. Each primitive also has a &quot;global transform&quot; (<code>primitive-transform</code>) which is a transform matrix that combines the primitive's and the parent's matrices to get a world-space transform. To get the world-space location and orientation you will want the <code>global-location</code> and <code>global-orientation</code>. Note that the two transform matrices may be identical if the primitive has no parent to speak of.</p><p>The <code>detect-hits</code> function takes an array filled with <code>hit</code> instances, as well as a start and (exclusive) end index of the range it is allowed to fill. It will return the index of the last element that wasn't modified. Thus, no hits means <code>(= start (detect-hits ...))</code>.</p><p>This interface allows you to cache and re-use hit instances, avoiding spurious allocation. If you know you only need one hit at a time, you can also use the more convenient <code>detect-hit</code>.</p><p>Any hit covered by <code>detect-hits</code> must fill out the fields <code>a</code>, <code>b</code>, <code>location</code>, and <code>normal</code>, which describe the intersection in world space. It may also fill out the rest of the hit's fields depending on the properties of the objects involved in the test.</p><p>To perform raycasts, a <code>ray</code> instance can be used. This works through the same <code>intersects-p</code> interface, though every ray-primitive test also has a specific implicit function, named like <code>ray-box-p</code>, which takes the required parameters implicitly, and returns either <code>NIL</code> or a float describing the &quot;time&quot; along the ray at which the ray hit the primitive.</p><p>Other non-primitive objects may also support the <code>intersects-p</code> and <code>detect-hits</code> interfaces.</p><h2 id="testing methods">Testing Methods</h2><p>Trial implements a variety of collision testing methods. They are:</p><ul><li><p>&quot;Bespoke&quot;<br>These are precise collision methods for a specific pair of primitives. They should provide the most accurate and efficient response.</p></li><li><p><a class="external-link" href="https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm">GJK</a>+<a class="external-link" href="https://graphics.stanford.edu/courses/cs468-01-fall/Papers/van-den-bergen.pdf">EPA</a><br>The Gilbert-Johnson-Keerthi and Expanding-Polytope-Algorithm methods for collision detection, which are very commonly used in physics engines. This is used for generic raycasts and distance estimation.</p></li><li><p><a class="external-link" href="https://en.wikipedia.org/wiki/Minkowski_Portal_Refinement">MPR/Xenocollide</a><br>The Minkowski-Portal-Refinement algorithm. This is used for generic intersection tests.</p></li><li><p><a class="external-link" href="https://graphics.stanford.edu/courses/cs448b-00-winter/papers/TR97-05.pdf">Voronoi-Clip</a><br>An alternate scheme based on voronoi regions. This is currently unused.</p></li></ul></article></body></html>