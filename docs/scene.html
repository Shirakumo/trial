<!DOCTYPE html><html><head><title>Trial / Scene Graph</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Like many engines, Trial includes a &quot;scene graph&quot; – a tree of nodes in which the objects that are drawn or are interactable are organised. Each node is a scene-node with a container pointer to its parent node. Nodes that can contain other child nodes are containers. Nodes that can be named are called entitys. If an entity is named, it is uniquely identified by its name within the scene it is contained in. An entity can be obtained via its name with the node function."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Scene Graph"><meta property="og:url" content="https://shirakumo.org/docs/trial/scene.mess.html"><meta property="og:description" content="Like many engines, Trial includes a &quot;scene graph&quot; – a tree of nodes in which the objects that are drawn or are interactable are organised. Each node is a scene-node with a container pointer to its parent node. Nodes that can contain other child nodes are containers. Nodes that can be named are called entitys. If an entity is named, it is uniquely identified by its name within the scene it is contained in. An entity can be obtained via its name with the node function."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="scene graph">Scene Graph</h1><p>Like many engines, Trial includes a &quot;scene graph&quot; – a tree of nodes in which the objects that are drawn or are interactable are organised. Each node is a <code>scene-node</code> with a <code>container</code> pointer to its parent node. Nodes that can contain other child nodes are <code>container</code>s. Nodes that can be named are called <code>entity</code>s. If an <code>entity</code> is named, it is uniquely identified by its name within the <code>scene</code> it is contained in. An entity can be obtained via its name with the <code>node</code> function.</p><h2 id="graph operations">Graph Operations</h2><p>Operating on the graph is rather simple: <code>enter</code> is used to introduce a node into a container, and <code>leave</code> is used to remove it again. When a node is <code>enter</code>ed, it is also <code>register</code>ed on the graph's root <code>scene</code>. Similarly, when it is left, the node and any children it might have are first <code>deregister</code>ed. When the name of an <code>entity</code> is changed via <code>setf</code>, the object is also first <code>deregister</code>ed and then re-<code>register</code>ed after the name change.</p><p>Each <code>container</code> must be a <code>sequence</code> and as such can be iterated over as one, using either <code>for:for</code> or <code>sequences:dosequence</code>. All other standard sequence operations are naturally required to be supported as well.</p><p>You can also <code>clear</code> a container fully, though note that this will not recursively clear if the container contained other containers. When a container is <code>finalize</code>d, all of its children are also finalized and the container is <code>clear</code>ed, though as with all finalization you should not rely on any particular state after finalization.</p><p>Finally, you can check whether a node is within a container with <code>contained-p</code>, and retrieve the container it is in (if any) with the <code>container</code> function. To retrieve the root scene, simply use the <code>scene</code> function.</p><h2 id="reacting to scene changes">Reacting to Scene Changes</h2><p>When a node in the scene graph is added or removed, you can react to that change at the immediate child level via methods on <code>enter</code> and <code>leave</code>. Any <code>enter</code> and <code>leave</code> operation will also bubble upwards (to the root) of the tree via <code>register</code> and <code>deregister</code> calls correspondingly, so you can react to changes lower down in the tree via methods on those functions.</p><p>Note that all of those functions are called synchronously, so performing expensive operations in them will also make scene tree changes expensive as well. However, it also allows you to perform consistency checks and error out, should an insertion or removal be considered invalid.</p><p>In order to react to changes elsewhere in the scene graph, you can add an event handler for the <code>register</code> and <code>deregister</code> events. Note that these will be asynchronous and will only be handled after the change has already been performed. You can also react to a scene change itself via the <code>scene-change</code> event.</p><h2 id="entity mixins">Entity Mixins</h2><p>By themselves nodes don't actually do anything. Often you'd like the nodes to carry some properties such as a location, orientation, etc. To this end, Trial offers a number of mixin classes:</p><ul><li><p><code>located-entity</code><br>An entity with a <code>location</code> vec3.</p></li><li><p><code>sized-entity</code><br>An entity with a <code>bsize</code> vec3 describing the half-size of the entity's bounding box.</p></li><li><p><code>oriented-entity</code><br>An entity that is pointing in the <code>orientation</code> direction according to the <code>up</code> vector.</p></li><li><p><code>rotated-entity</code><br>An entity that is rotated by the <code>rotation</code> quaternion.</p></li><li><p><code>axis-rotated-entity</code><br>An entity that is rotated around the <code>axis</code> by <code>angle</code>.</p></li><li><p><code>pivoted-entity</code><br>An entity that is pivoted by <code>pivot</code>.</p></li><li><p><code>scaled-entity</code><br>An entity that is scaled by <code>scaling</code>.</p></li><li><p><code>transformed-entity</code><br>An entity with a <code>transform</code> gizmo attached via <code>tf</code>. It also supports convenience accessors for <code>location</code>, <code>scaling</code>, <code>rotation</code>, <code>axis</code>, <code>angle</code>.<br>This is what all nodes have in a typical game engine. The transform gizmo is a convenient way to encapsulate separated affine transformations.</p></li></ul><p>Note that if you use multiple of these mixins that the order in which you specify them in the superclass list matters, as it determines the order in which their transformations apply to the <code>model-matrix</code> via <code>apply-transforms</code>.</p><h2 id="container types">Container Types</h2><p>While you can create your own container types when necessary, Trial already provides a number of containers that should fit almost every need out there.</p><ul><li><p><code>array-container</code><br>A container backed by a simple-vector. Insertion is O(1) and simply adds to the back, and removal is O(n). Iteration should be fast and memory-efficient.</p></li><li><p><code>bag</code><br>A container where the order of elements is not guaranteed to be consistent. However, in return, insertion and removal are both O(1), and iteration is also fast and memory-efficient. This should be the default container type unless you expect a very small number of elements.</p></li><li><p><code>hash-table-container</code><br>A container backed by a simple hash table. Iteration order is not guaranteed, but insertion and removal are both O(1). Additionally, setting elements via <code>elt</code> does not &quot;make sense&quot; as there's no guarantee about the index of new elements.</p></li><li><p><code>layered-container</code><br>A container that segregates objects into a multiple <code>bag</code>s depending on their <code>layer-index</code>. The container needs to be initialised with the correct <code>layer-count</code>. Any object with a layer-index beyond [0,layer-count] is clamped to within that range.</p></li><li><p><code>list-container</code><br>A container backed by a list. Insertion is O(1) and simply adds to the front, and removal is O(n). Iteration is not memory efficient due to the cons chain.</p></li></ul><p>Defining your own container types is simple – all you need to do is subclass <code>container</code>, and implement <code>clear</code>, <code>enter</code>, <code>leave</code>, and the necessary sequence methods (most notably <code>sequences:make-sequence-iterator</code>).</p></article></body></html>