<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="scene graph">Scene Graph</h1><p>Like many engines, Trial includes a &quot;scene graph&quot; â€“ a tree of nodes in which the objects that are drawn or are interactable are organised. Each node is a <code>scene-node</code> with a <code>container</code> pointer to its parent node. Nodes that can contain other child nodes are <code>container</code>s. Nodes that can be named are called <code>entity</code>s. If an <code>entity</code> is named, it is uniquely identified by its name within the <code>scene</code> it is contained in. An entity can be obtained via its name with the <code>entity</code> function.</p><h2 id="graph operations">Graph Operations</h2><p>Operating on the graph is rather simple: <code>enter</code> is used to introduce a node into a container, and <code>leave</code> is used to remove it again. When a node is <code>enter</code>ed, it is also <code>register</code>ed on the graph's root <code>scene</code>. Similarly, when it is left, the node and any children it might have are first <code>deregister</code>ed. When the name of an <code>entity</code> is changed via <code>setf</code>, the object is also first <code>deregister</code>ed and then re-<code>register</code>ed after the name change.</p><p>Each <code>container</code> must be a <code>sequence</code> and as such can be iterated over as one, using either <code>for:for</code> or <code>sequences:dosequence</code>. All other standard sequence operations are naturally required to be supported as well.</p><h2 id="mixins">Mixins</h2><p>By themselves nodes don't actually do anything. Often you'd like the nodes to carry some properties such as a location, orientation, etc. To this end, Trial offers a number of mixin classes:</p><ul><li><p><code>located-entity</code><br>An entity with a <code>location</code> vec3.</p></li><li><p><code>sized-entity</code><br>An entity with a <code>bsize</code> vec3 describing the half-size of the entity's bounding box.</p></li><li><p><code>oriented-entity</code><br>An entity that is pointing in the <code>orientation</code> direction according to the <code>up</code> vector.</p></li><li><p><code>rotated-entity</code><br>An entity that is rotated by the <code>rotation</code> quaternion.</p></li><li><p><code>axis-rotated-entity</code><br>An entity that is rotated around the <code>axis</code> by <code>angle</code>.</p></li><li><p><code>pivoted-entity</code><br>An entity that is pivoted by <code>pivot</code>.</p></li><li><p><code>scaled-entity</code><br>An entity that is scaled by <code>scaling</code>.</p></li><li><p><code>transformed-entity</code><br>An entity with a <code>transform</code> gizmo attached via <code>tf</code>. It also supports convenience accessors for <code>location</code>, <code>scaling</code>, <code>rotation</code>, <code>axis</code>, <code>angle</code>.<br>This is what all nodes have in a typical game engine. The transform gizmo is a convenient way to encapsulate separated affine transformations.</p></li></ul><p>Note that if you use multiple of these mixins that the order in which you specify them in the superclass list matters, as it determines the order in which their transformations apply to the <code>model-matrix</code>.</p></article>