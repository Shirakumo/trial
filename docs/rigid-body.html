<!DOCTYPE html><html><head><title>Trial / Rigid Body Physics Simulations</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Rigid body physics simulate &quot;stiff&quot; bodies without any deformation. Bodies may have any shape, and may potentially have any internal mass distribution, though are always reduced down to one or more primitive convex shapes with a global (for the entire object) center of mass and inertia tensor."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Rigid Body Physics Simulations"><meta property="og:url" content="https://shirakumo.org/docs/trial/rigid-body.mess.html"><meta property="og:description" content="Rigid body physics simulate &quot;stiff&quot; bodies without any deformation. Bodies may have any shape, and may potentially have any internal mass distribution, though are always reduced down to one or more primitive convex shapes with a global (for the entire object) center of mass and inertia tensor."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="rigid body physics simulations">Rigid Body Physics Simulations</h1><p>Rigid body physics simulate &quot;stiff&quot; bodies without any deformation. Bodies may have any shape, and may potentially have any internal mass distribution, though are always reduced down to one or more primitive convex shapes with a global (for the entire object) center of mass and inertia tensor.</p><p>Please see <a class="external-link" href="physics.html">physics systems</a> for a general overview of physics systems in Trial.</p><h2 id="rigid bodies">Rigid Bodies</h2><p>At the core on the object side lies the <code>rigidbody</code> which adds all the necessary information onto the <code>physics-entity</code> for the simulation. For the current information, it makes use of a transform object via the <code>transformed-entity</code>. For the velocities, it adds the <code>rotation</code> field to the physics entity's <code>velocity</code>, and for the rotational analogue of <code>force</code> it adds the <code>torque</code>. Finally, it also adds an <code>angular-damping</code> factor to the <code>damping</code> for linear motion.</p><p>As mentioned, every rigidbody is made up of one or more <code>physics-primitives</code>, which are <code>primitive</code> objects that describe the geometry used for collisions. This geometry is usually separate and massively simplified from the geometry used for visualising the entity.</p><p>Trial currently does not offer any tools to automatically derive a set of convex primitives to describe your shape and it is thus up to you to construct the set and initialise the rigidbody appropriately.</p><p>Rigid bodies also need an inertia tensor to describe their mass distribution. This tensor can be manually set via <code>inertia-tensor</code>. The system will also automatically compute it for you when setting the primitives, if it knows how to.</p><p>Note that no two rigidbodies can share a primitive instance. When you assign a primitive to a rigidbody, control over that primitive is handed over to the rigidbody.</p><p>If you need to impart forces on the object, you should typically use <code>impact</code> or <code>impact-local</code> to do so, as this will take care of translating the force from the given contact point into the appropriate amounts of linear and angular acceleration.</p><h2 id="primitives">Primitives</h2><p>Besides describing the composition of a rigidbody, primitives are also the way by which collision detections are handled. Each primitive has a link back to its <code>entity</code>, a <code>material</code> it is made out of, a <code>local-transform</code> that describes how the primitive is offset from the main rigidbody, and a <code>transform</code> that describes the current world-space transform for the primitive. The transform is updated automatically by the rigidbody and is used during collision detection.</p><p>The material for the primitive is used to determine interaction properties. Please see the respective section in the overview on <a class="external-link" href="physics.html">physics systems in Trial</a>.</p><p>In order to detect contacts between two primitives the function <code>detect-hits</code> is used. Similar to <code>generate-hits</code> this fills a passed vector of <code>hit</code> instances with data and returns the new start index.</p><p>Trial currently offers the following primitives, as well as collision detection between them, out of the box:</p><ul><li><p><code>sphere</code><br>A sphere with a <code>radius</code></p></li><li><p><code>ellipsoid</code><br>An ellipsoid with a <code>radius</code> in every dimension.</p></li><li><p><code>plane</code><br>An infinite plane facing towards the <code>normal</code> at the <code>offset</code> along that normal.</p></li><li><p><code>half-space</code><br>An infinite volume below the <code>offset</code> along the <code>normal</code>.</p></li><li><p><code>box</code><br>A box with the half-size <code>bsize</code>.</p></li><li><p><code>cylinder</code><br>An upright cylinder with a <code>radius</code> and a <code>height</code> along the +Y axis.</p></li><li><p><code>cone</code><br>An upright cone with a <code>radius</code> and a <code>height</code> along the +Y axis. The tip is in Y+.</p></li><li><p><code>pill</code><br>An upright pill with a <code>radius</code> and a <code>height</code> along the +Y axis. Like a cylinder, but with spherical caps of <code>radius</code>. A <code>height</code> of zero is equivalent to a <code>sphere</code>.</p></li><li><p><code>triangle</code><br>A triangle with <code>A</code>, <code>B</code>, and <code>C</code> corners.</p></li><li><p><code>general-mesh</code><br>A general triangle mesh with packed <code>vertices</code> and <code>faces</code> arrays.</p></li><li><p><code>convex-mesh</code><br>A triangle mesh that must be convex, with packed <code>vertices</code> and <code>faces</code> arrays.</p></li></ul><p>Note that there is currently no support for complex convex primitives, nor for automated tessellation of concave geometry into sets of convex primitives. Please help us out by adding support for that!</p><h2 id="rigid body systems">Rigid Body Systems</h2><p>Finally, to actually run a simulation between rigidbodies, there's the <code>rigidbody-system</code>. It holds the usual <code>physics-system</code> properties, as well as the <code>velocity-eps</code> and <code>depth-eps</code>, two constants to aid in the resolution stability by ignoring intersections that would be too small.</p><p>The system implements <code>generate-hits</code> and <code>resolve-hits</code>, so there's nothing more to do to make use of a rigidbody system.</p><p>The system implemented here is called an &quot;impulse-based micro-collisions engine&quot;. This has a few consequences for the simulations. For instance, the engine does not currently deal well with long collision chains such as when stacking many objects on top of each other. It will lead to jiggling and eventual collapse.</p><p>You can counter-act this by putting such stacks to sleep first, but this is only suitable for select scenarios.</p><p>To improve simulation stability further, the system would have to be revised to properly handle simultaneous contacts.</p></article></body></html>