<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="standard renderer protocol">Standard Renderer Protocol</h1><p>The <a class="external-link" href="render-pipeline.html">render pipeline</a> is a very loose and low-level system that organises rendering information. Most notably, it does not provide a protocol for dealing with materials, light sources, lighting models, and other associated problems. This is where the standard renderer protocol comes in.</p><h2 id="standard information">Standard Information</h2><p>Every <code>standard-renderer-pass</code> will provide the following variables to the shaders:</p><ul><li><p><code>mat4</code> <code>view_matrix</code><br>The camera's view matrix</p></li><li><p><code>mat4</code> <code>projection_matrix</code><br>The camera's projection matrix</p></li><li><p><code>vec2</code> <code>view_size</code><br>The size of the view / window</p></li><li><p><code>vec3</code> <code>camera_position</code><br>The position of the camera in world space</p></li><li><p><code>float</code> <code>tt</code><br>The current total time passage (see <code>tick</code>)</p></li><li><p><code>float</code> <code>dt</code><br>The physics time step (see <code>tick</code>)</p></li><li><p><code>float</code> <code>fdt</code><br>The delta time since the last frame was rendered</p></li></ul><p>The following variables must be set in the fragment shader:</p><ul><li><p><code>vec3</code> <code>world_position</code><br>The position of the current fragment in world space</p></li><li><p><code>vec3</code> <code>view_position</code><br>The position of the current fragment in view space</p></li><li><p><code>vec3</code> <code>normal</code><br>The normal of the current fragment</p></li><li><p><code>vec2</code> <code>uv</code><br>The UV coordinate of the current fragment for its respective textures</p></li><li><p><code>vec4</code> <code>color</code><br>The color to be output for the current fragment</p></li></ul><p>An implementation of the <code>standard-renderer-pass</code> should set these values through the use of the following functions:</p><ul><li><p><code>standard_init</code><br>Called once at the beginning of the fragment stage</p></li><li><p><code>standard_shade</code><br>Called per active light</p></li><li><p><code>standard_mix</code><br>Called to accumulate the shaded colour</p></li><li><p><code>standard_finish</code><br>Called once at the end of the fragment stage</p></li></ul><p>You may use glsl-toolkit's standard method combinators to neatly override and combine behaviours. Appending <code>@after</code>, <code>@before</code>, or <code>@around</code> to your function names will cause the same semantic behaviour as you'd expect from the standard method combination, though without any regard for argument or return types. In <code>@around</code> or primary &quot;methods&quot;, you may also use <code>call_next_method</code> to call the next &quot;method&quot;, and <code>next_method_p</code> to determine whether there is one or not.</p><p>The <code>standard-renderable</code> expects a <code>vertex-array</code> with the following attributes:</p><ol><li value="0"><p><code>vec3</code> position</p></li><li value="1"><p><code>vec2</code> UV coordinate</p></li><li value="2"><p><code>vec3</code> normal vector</p></li></ol><p>It will automatically supply the following variables to shaders:</p><ul><li><p><code>mat4</code> <code>model_matrix</code><br>The model transformation matrix</p></li><li><p><code>mat4</code> <code>inv_model_matrix</code><br>The model inverse of the model transformation matrix</p></li></ul><p>And based on those compute the necessary variables in the vertex shader. It also provides a <code>standard_init@before</code> method in the fragment stage to set the <code>world_position</code>, <code>view_position</code>, <code>normal</code>, and <code>uv</code> variables mentioned above.</p><h2 id="lights">Lights</h2><p>We provide a standardised light system through <code>standard-light</code>, and the entities <code>ambient-light</code>, <code>located-light</code>, <code>point-light</code>, <code>directional-light</code>, and <code>spot-light</code>. Any light holds a radiance <code>color</code> and a toggle for whether it is currently <code>active-p</code>. Each light also holds a <code>location</code> and <code>bsize</code>, even if they do not necessarily have any actual size. The extent information is used to allow light allocation in the renderer to be optimised transparently without having to know about specific light types.</p><p>Lights with a location (<code>located-light</code>) also have a <code>linear-falloff</code> and <code>quadratic-falloff</code> to describe how their radiance diminishes over distance based on this simple formula:</p><code style="display:block" class="code-block" data-language="mathjax"><pre>R_{effective} = R_{source} / (1 + F_{linear}*d + F_{quadratic}*d^2)</pre></code><p>A spot light also has two factors to define the size of the illuminated spot, the <code>outer-radius</code> and <code>inner-radius</code>, which are specified as half-angles. The outer radius defines the maximal radius of the spot, and the inner radius describes the radius within which the radiance is at its maximum. An outer radius of 90 would equal a directional light.</p><p>A <code>standard-renderer-pass</code> limits the number of active lights at once. By default this is 128, though it can be customised with the <code>:max-lights</code> option at construction. In order to render a light, it must be <code>enabled</code> on the pass, and may be <code>disabled</code> again to remove it. If more lights are enabled than supported in the renderer, the oldest light is automatically evicted.</p><p>The assigned ID of the light (if any) can be obtained via the <code>local-id</code> function. This ID will not change for the light unless it is removed.</p><p>Note that the properties of <code>light</code> instance are not automatically synchronised with the light information used in a <code>standard-renderer-pass</code>. If a light's properties have changed and you would like to make those changes reflect in the pass, you must call <code>notice-update</code> with the light and pass.</p><p>The <code>light-cache-render-pass</code> takes care of automatically enabling and disabling lights based on their distance from the camera's current <code>focal-point</code>. This is usually an adequate heuristic for determining the set of active lights, as light contribution falls off dramatically with distance. The <code>light-cache-render-pass</code> tracks an <code>ambient-light</code> instance specially to ensure that it is always active, however.</p><h2 id="materials">Materials</h2><p>We also provide a standardised materials system through <code>material</code>. However, since the required material information varies highly depending on the lighting system used, aside from a <code>textures</code> array and a <code>name</code>, no other properties are mandated for the base class.</p><p>Materials can be accessed by name via <code>material</code> and asset importers that provide materials should call <code>update-material</code> to ensure that the material information is registered and updated. This allows materials to be shared across multiple models.</p><p>Any material implementation must provide a method for <code>texture-names</code>, which are used to read out initargs by name and slot them into the corresponding index in the <code>textures</code> vector.</p><p>A <code>standard-renderer-pass</code> has a limited number of available slots for materials, similar to lights. The number of material slots can be configured via the <code>:max-materials</code> initarg on construction. Same as for lights, materials must be <code>enabled</code> to be used, and also follow the same LRU eviction strategy.</p><p>When <code>enable</code>ing a material, all its textures are also automatically enabled. The number of available texture slots is <strong>not</strong> user-configurable, and is instead based on the runtime value of OpenGL's max-texture-image-units, sans any texture slots taken up by the pass itself.</p><p>Any implementation of <code>standard-renderable</code> must make sure to enable the required materials and bind the associated textures. The <code>single-material-renderable</code> will automatically call <code>render-with</code> on the pass, material, and shader program, to allow the renderer to configure the material properties as required and bind the textures.</p><p>Any implementation of <code>standard-renderer-pass</code> must implement <code>material-block-type</code> to return the class name of a <code>gl-struct</code> that will accept the <code>:size</code> construction initarg and hold a GL slot called <code>materials</code> that is an array of the actual material struct instances, with <code>:size</code> number of elements.</p><p>An implementation must also be provided for <code>transfer-to</code> between two instances of the material type. This is used to update the material property in the backed buffers from the material representation used by entities.</p><p>You may also want to provide a <code>coerce-object</code> method for your material type from other material types, as model importers may not directly supply your ideal material type.</p><h2 id="shadows">Shadows</h2><p>In real-time rendering systems shadows are usually handled separately, and often implemented via shadow maps, where each light maintains a depth map by which occlusion can be determined. The <code>standard-shadows-pass</code> provides an automated implementation of shadow maps for all standard light types. This pass keeps a limited set of shadow maps, and can be configured via the following initargs:</p><ul><li><p><code>:max-shadow-casters</code><br>The maximal number of lights that can cast shadows. Note that point lights take up the space of 6 directional or spot lights. This can only be provided at construction time.</p></li><li><p><code>:shadow-map-resolution</code><br>The resolution of the shadow maps. Higher resolution leads to better accuracy of the shadow projections. This can only be provided at construction time.</p></li><li><p><code>:sample-count</code><br>The number of poisson samples taken to determine the shadow value. Higher values provide smoother results, but at higher render cost.</p></li><li><p><code>:sample-spread</code><br>The spread between samples. Higher values create blurrier edges but may avoid shadow acne better.</p></li></ul><p>Since the number of shadow maps is limited, a light that is <code>enable</code>d is only given a shadow map if there is enough space free. Please note that shadow maps are quite expensive in general, as each map requires a re-rendering of the entire scene, which can be quite costly with large numbers of objects or dense geometry.</p><p>The shadow calculation is transparently hooked into the <code>evaluate_light_*</code> functions provided by the <code>standard-renderer-pass</code>, and thus requires no further attention from the shading implementation.</p><p>You may dynamically de/activate a light's shadow casting by setting <code>cast-shadows-p</code>, and then <code>notice-update</code> on the light and pass.</p></article>