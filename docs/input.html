<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
}</style><h1 id="input and mapping system">Input and Mapping System</h1><p>In Trial getting inputs from the user is divided up into three parts: raw input events, actions, and mappings.</p><h2 id="raw inputs">Raw Inputs</h2><p>Raw device inputs are delivered via the <a class="external-link" href="event-loop.html">event system</a>. Each class of device has its own events derived from <code>input-event</code>:</p><ul><li><p><code>keyboard-event</code></p><ul><li><p><code>key-event</code> (<code>key</code>, <code>repeat-p</code>, <code>modifiers</code>)</p><ul><li><p><code>key-press</code></p></li><li><p><code>key-release</code></p></li></ul></li><li><p><code>text-entered</code> (<code>text</code>)</p></li></ul></li><li><p><code>mouse-event</code> (<code>pos</code>)</p><ul><li><p><code>mouse-button-event</code> (<code>button</code>)</p><ul><li><p><code>mouse-press</code></p></li><li><p><code>mouse-release</code></p></li></ul></li><li><p><code>mouse-move</code> (<code>old-pos</code>)</p></li></ul></li><li><p><code>gamepad-event</code> (<code>device</code>)</p><ul><li><p><code>gamepad-button-event</code> (<code>button</code>)</p><ul><li><p><code>gamepad-press</code></p></li><li><p><code>gamepad-release</code></p></li></ul></li><li><p><code>gamepad-move</code> (<code>axis</code>, <code>pos</code>, <code>old-pos</code>)</p></li><li><p><code>gamepad-added</code></p></li><li><p><code>gamepad-removed</code></p></li></ul></li></ul><p>Trial's systems allow distinguishing between multiple gamepads, but <em>not</em> between multiple keyboards or mice.</p><p>You should almost never have to directly interface with these events, as they are not user-configurable. Instead, you should use the input mapping system.</p><p>Input events are provided by the rendering backend and cl-gamepad, and should automatically appear in the <code>scene</code> of your <code>main</code>.</p><h2 id="actions">Actions</h2><p><code>action</code>s are abstract events that correspond to in-game actions. Actions are typically mapped from existing events, and you can look at the origin with <code>source-event</code>. New actions are defined with <code>define-action</code>. The superclass list is used to attach the event to one or more <code>action-set</code>s.</p><p><code>action-set</code>s are ways to group actions together under a set that allows you to activate and deactivate all actions at once. This way you can have a separate sets of actions for menu navigation, for in-game, etc. Sets can be activated by setting <code>active-p</code>. An action will be active as long as at least one of the sets it is a subclass of is active.</p><p>Often it's also desired to have <code>action-set</code>s be mutually exclusive. In that case, making the sets a subclass of <code>exclusive-action-set</code> will ensure all others will be automatically deactivated when another is activated.</p><p>Most actions will represent some kind of event request, such as &quot;jump&quot;, &quot;interact&quot;, &quot;select next&quot;, &quot;confirm&quot;, etc. For some games however it can also make more sense to have actions that carry a value, such as &quot;gas&quot; or &quot;camera tilt&quot;. For the latter, the superclasses <code>analog-action</code>, <code>directional-action</code>, and <code>spatial-action</code> are useful.</p><h2 id="mappings">Mappings</h2><p>Actions by themselves allow you to define player input with a layer of abstraction, but they won't be useful unless actions can be fired by user inputs. This is where the mapping layer comes into play.</p><p>Event mappings are executed through <code>map-event</code>, which is handled by the <code>controller</code> when it is present in the scene. If you do not have a controller present, you should call <code>map-event</code> yourself somehow.</p><p>Defining how events are mapped is, in the most generic way, done via <code>define-mapping-function</code>. The function it defines is invoked for each event, and can then just issue other events back onto the loop. Typically though this is <em>too</em> generic and open-ended, and also doesn't allow players to customise how the mapping works.</p><p>Instead, a <code>keymap.lisp</code> file should be defined, which describes the mappings. This file will contain all the default mappings present, and Trial will emit a new file of the same structure when the user changes the mappings. Trial will also take care of keeping track of the action's state: whether it is currently being <code>retained</code> or not. Often it is much more useful to be able to ask what the action's retained state is. For digital actions this means whether it's &quot;active&quot; or not. For others it's what the last value, position, or location was.</p><p>The file describing action mappings is in s-expression format and contains definitions like this:</p><code style="display:block" class="code-block"><pre>(trigger jump
  (key :one-of (:space))
  (button :one-of (:b :a)))</pre></code><p>Meaning: when the <code>:space</code> key is pressed, or when the <code>:b</code> or <code>:a</code> button on a gamepad is pressed, fire a <code>jump</code> action.</p><p>The possible mapping types are <code>trigger</code> for digital maps, and <code>bind</code> for analogue or directional maps.</p><p>The possible binding sources are <code>key</code> for keyboard keys, <code>button</code> for gamepad buttons, <code>axis</code> for gamepad axes, and <code>mouse</code> for mouse buttons. Each of the bindings also accepts the following parameters:</p><ul><li><p><code>:one-of</code> the qualifiers to look out for, typically the names of the buttons</p></li><li><p><code>:threshold</code> the value at which the input becomes &quot;active&quot;. Defaults to 0.5, but only used for <code>axis</code> mappings.</p></li><li><p><code>:toggle</code> if NIL (default) then the action is retained while the input is &quot;active&quot;. Otherwise the action stays retained until the input becomes &quot;inactive&quot; and then &quot;active&quot; again. Only used for <code>trigger</code> mappings.</p></li><li><p><code>:value</code> what value should be used for the action when the input is &quot;active&quot;. Only used for <code>bind</code> mappings on non-<code>axis</code> bindings.</p></li></ul><p>Querying and interacting with the mappings can of course also be done programmatically outside of the <code>keymap.lisp</code> source file. On the most basic, one can <code>load-mapping</code> and <code>save-mapping</code> to interact with the file. Finding mappings that spawn an action can be done via <code>find-action-mappings</code>. It can also be useful to capture an input event and turn that into on <code>action-mapping</code> or vice-versa. To do so, simply use <code>event-to-action-mapping</code>, or the inverse, <code>event-from-action-mapping</code>.</p><h2 id="miscellaneous">Miscellaneous</h2><p>Sometimes, particularly when switching action sets, it can be useful to reset or clear retentions. <code>clear-retained</code> will reset all retention information. <code>reset-retained</code> will attempt to &quot;back fill&quot; retention information based on current device state.</p><p>It can also be useful to inhibit mapping of any key events, such as when the user is typing into a text field, as then key presses could instead lead to unintended actions being taken. To control the mapping simply set <code>+map-key-events+</code>.</p><p>Finally, default retentions for all mouse buttons and keyboard keys are kept. The retention is simply named after the key or button. These retentions can be useful for debugging purposes.</p></article>