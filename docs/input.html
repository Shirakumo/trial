<!DOCTYPE html><html><head><title>Trial / Input and Mapping System</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="In Trial getting inputs from the user is divided up into three parts: raw input events, actions, and mappings."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Input and Mapping System"><meta property="og:url" content="https://shirakumo.org/docs/trial/input.mess.html"><meta property="og:description" content="In Trial getting inputs from the user is divided up into three parts: raw input events, actions, and mappings."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="input and mapping system">Input and Mapping System</h1><p>In Trial getting inputs from the user is divided up into three parts: raw input events, actions, and mappings.</p><h2 id="raw inputs">Raw Inputs</h2><p>Raw device inputs are delivered via the <a class="external-link" href="event-loop.html">event system</a>. Each class of device has its own events derived from <code>input-event</code>:</p><ul><li><p><code>keyboard-event</code></p><ul><li><p><code>key-event</code> (<code>key</code>, <code>repeat-p</code>, <code>modifiers</code>)</p><ul><li><p><code>key-press</code></p></li><li><p><code>key-release</code></p></li></ul></li><li><p><code>text-entered</code> (<code>text</code>)</p></li></ul></li><li><p><code>mouse-event</code> (<code>pos</code>)</p><ul><li><p><code>mouse-button-event</code> (<code>button</code>)</p><ul><li><p><code>mouse-press</code></p></li><li><p><code>mouse-release</code></p></li></ul></li><li><p><code>mouse-move</code> (<code>old-pos</code>)</p></li></ul></li><li><p><code>gamepad-event</code> (<code>device</code>)</p><ul><li><p><code>gamepad-button-event</code> (<code>button</code>)</p><ul><li><p><code>gamepad-press</code></p></li><li><p><code>gamepad-release</code></p></li></ul></li><li><p><code>gamepad-move</code> (<code>axis</code>, <code>pos</code>, <code>old-pos</code>)</p></li><li><p><code>gamepad-added</code></p></li><li><p><code>gamepad-removed</code></p></li></ul></li></ul><p>Trial's systems allow distinguishing between multiple gamepads, but <em>not</em> between multiple keyboards or mice.</p><p>You should almost never have to directly interface with these events, as they are not user-configurable. Instead, you should use the input mapping system.</p><p>Input events are provided by the rendering backend and cl-gamepad, and should automatically appear in the <code>scene</code> of your <code>main</code>.</p><h2 id="actions">Actions</h2><p><code>action</code>s are abstract events that correspond to in-game actions. Actions are typically mapped from existing events, and you can look at the origin with <code>source-event</code>. New actions are defined with <code>define-action</code>. The superclass list is used to attach the event to one or more <code>action-set</code>s.</p><p><code>action-set</code>s are ways to group actions together under a set that allows you to activate and deactivate all actions at once. This way you can have a separate sets of actions for menu navigation, for in-game, etc. Sets can be activated by setting <code>active-p</code>. An action will be active as long as at least one of the sets it is a subclass of is active.</p><p>Often it's also desired to have <code>action-set</code>s be mutually exclusive. In that case, making the sets a subclass of <code>exclusive-action-set</code> will ensure all others will be automatically deactivated when another is activated.</p><p>Most actions will represent some kind of event request, such as &quot;jump&quot;, &quot;interact&quot;, &quot;select next&quot;, &quot;confirm&quot;, etc. For some games however it can also make more sense to have actions that carry a value, such as &quot;gas&quot; or &quot;camera tilt&quot;. For the latter, the superclasses <code>analog-action</code>, and <code>directional-action</code>.</p><h2 id="mappings">Mappings</h2><p>Actions by themselves allow you to define player input with a layer of abstraction, but they won't be useful unless actions can be fired by user inputs. This is where the mapping layer comes into play.</p><p>Event mappings are executed through <code>map-event</code>, which is handled by the <code>controller</code> when it is present in the scene. If you do not have a controller present, you should call <code>map-event</code> yourself somehow.</p><p>Defining how events are mapped is, in the most generic way, done via <code>define-mapping-function</code>. The function it defines is invoked for each event, and can then just issue other events back onto the loop. Typically though this is <em>too</em> generic and open-ended, and also doesn't allow players to customise how the mapping works.</p><p>Instead, a <code>keymap.lisp</code> file should be defined, which describes the mappings. This file will contain all the default mappings present, and Trial will emit a new file of the same structure when the user changes the mappings. Trial will also take care of keeping track of the action's state. For digital actions this means whether it's &quot;active&quot; or not, and can be retrieved with <code>retained</code>. For directional actions this means the current direction vector, which can be retrieved with <code>directional</code>. For analog actions this means the current value, which can be retrieved with <code>analog</code>.</p><p>The file describing action mappings is in s-expression format and contains definitions like this:</p><code style="display:block" class="code-block"><pre>(trigger jump
  (key :one-of (:space))
  (button :one-of (:b :a)))

(directional movement
  (stick :one-of ((:l-h :l-v) (:r-h :r-v) (:dpad-h :dpad-v)))
  (buttons :one-of ((:dpad-u :dpad-r :dpad-d :dupad-l)))
  (keys :one-of ((:w :a :s :d))))</pre></code><p>Meaning: when the <code>:space</code> key is pressed, or when the <code>:b</code> or <code>:a</code> button on a gamepad is pressed, fire a <code>jump</code> action. Map the left and right analog sticks, the dpad, and the wasd keys to the movement directional action.</p><p>The possible mapping types are <code>trigger</code> for digital maps, <code>directional</code> for directional maps, and <code>analog</code> for analog value maps.</p><p>Querying and interacting with the mappings can of course also be done programmatically outside of the <code>keymap.lisp</code> source file. On the most basic, one can <code>load-mapping</code> and <code>save-mapping</code> to interact with the file. Finding mappings that spawn an action can be done via <code>find-action-mappings</code>. It can also be useful to capture an input event and turn that into on <code>action-mapping</code> or vice-versa. To do so, simply use <code>event-to-action-mapping</code>, or the inverse, <code>event-from-action-mapping</code>.</p><h3 id="triggers">Triggers</h3><p>The possible binding sources are <code>key</code> for keyboard keys, <code>button</code> for gamepad buttons, <code>axis</code> for gamepad axes, and <code>mouse</code> for mouse buttons. Each of the bindings also accepts the following parameters:</p><ul><li><p><code>:one-of</code> the qualifiers to look out for, typically the names of the buttons</p></li><li><p><code>:threshold</code> the value at which the input becomes &quot;active&quot;. Defaults to 0.5, but only used for <code>axis</code> mappings.</p></li><li><p><code>:toggle</code> if NIL (default) then the action is retained while the input is &quot;active&quot;. Otherwise the action stays retained until the input becomes &quot;inactive&quot; and then &quot;active&quot; again. Only used for <code>trigger</code> mappings.</p></li><li><p><code>:value</code> what value should be used for the action when the input is &quot;active&quot;. Only used for <code>bind</code> mappings on non-<code>axis</code> bindings.</p></li></ul><h3 id="directionals">Directionals</h3><p>The possible binding sources are the same as for triggers, but with the additional <code>point</code> for relative mouse movement, <code>stick</code> to combine two analog axes, <code>buttons</code> to combine four gamepad buttons, and <code>keys</code> to combine four keyboard keys. The following parameters can be set depending on the binding source:</p><ul><li><p><code>:axis</code> The axis that the event maps to. Can be <code>:x</code>, <code>:y</code>, <code>:z</code>, or <code>:w</code></p></li><li><p><code>:one-of</code> Same as for triggers, except for <code>stick</code>, <code>buttons</code>, and <code>keys</code>, where each qualifier should be a list. For sticks, <code>(X Y)</code>, for buttons and keys <code>(Up Right Down Left)</code></p></li><li><p><code>:dead-zone</code> The dead-zone for <code>point</code> and <code>axis</code> below which no direction is recorded. Defaults to 0.1</p></li><li><p><code>:low-value</code> For digital events, the value in the &quot;low&quot;/&quot;up&quot; state. Defaults to 0.0</p></li><li><p><code>:high-value</code> For digital events, the value in the &quot;high&quot;/&quot;down&quot; state. Defaults to 1.0</p></li><li><p><code>:timeout</code> For <code>point</code> the timeout after which the mouse is reset to no movement. Defaults to 0.02</p></li><li><p><code>:scaling</code> For <code>point</code>, the scaling applied to the mouse direction. Allows both mouse speed correction as well as flipping of the mouse axes. Should be <code>(X Y)</code> scalar list, and defaults to <code>(1 1)</code></p></li></ul><h3 id="analog values">Analog Values</h3><p>The possible binding sources are the same as for triggers, but with the additional <code>buttons</code> to combine two gamepad buttons, and <code>keys</code> to combine two keyboard keys. The following parameters are also available:</p><ul><li><p><code>:one-of</code> Same as for triggers, except for <code>buttons</code>, and <code>keys</code>, where each qualifier should be a list of <code>(Up Down)</code></p></li><li><p><code>:dead-zone</code> The dead-zone for <code>point</code> and <code>axis</code> below which no direction is recorded. Defaults to 0.1</p></li><li><p><code>:low-value</code> For digital events, the value in the &quot;low&quot;/&quot;up&quot; state. Defaults to 0.0</p></li><li><p><code>:high-value</code> For digital events, the value in the &quot;high&quot;/&quot;down&quot; state. Defaults to 1.0</p></li></ul><h2 id="miscellaneous">Miscellaneous</h2><p>Sometimes, particularly when switching action sets, it can be useful to reset or clear retentions. <code>clear-retained</code> will reset all retention information. <code>reset-retained</code> will attempt to &quot;back fill&quot; retention information based on current device state.</p><p>It can also be useful to inhibit mapping of any key events, such as when the user is typing into a text field, as then key presses could instead lead to unintended actions being taken. To control the mapping simply set <code>+map-key-events+</code>.</p><p>Finally, default retentions for all mouse buttons and keyboard keys are kept. The retention is simply named after the key or button. These retentions can be useful for debugging purposes.</p></article></body></html>