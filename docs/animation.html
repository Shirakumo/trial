<!DOCTYPE html><html><head><title>Trial / Animation</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Trial includes support for describing animations – meaning how properties aught to evolve over time. These systems can be used to animate individual properties of objects or full skeleton rigs. The constructs on offer for this are fairly standard, allowing import from model files, including skinning and shape keys/morphs."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Animation"><meta property="og:url" content="https://shirakumo.org/docs/trial/animation.mess.html"><meta property="og:description" content="Trial includes support for describing animations – meaning how properties aught to evolve over time. These systems can be used to animate individual properties of objects or full skeleton rigs. The constructs on offer for this are fairly standard, allowing import from model files, including skinning and shape keys/morphs."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="animation">Animation</h1><p>Trial includes support for describing animations – meaning how properties aught to evolve over time. These systems can be used to animate individual properties of objects or full skeleton rigs. The constructs on offer for this are fairly standard, allowing import from model files, including skinning and shape keys/morphs.</p><p>The relevant concepts for animation are as follows:</p><ul><li><p><code>animation-track</code><br>An animation track is a sequence of keyframes and an interpolation method. Each keyframe is at a specific timecode, and has a value that the track should reach at that code. Timecodes between keyframes are interpolated between via the <code>interpolation</code> method. A track's value can be <code>sample</code>d for a desired time code.<br>Currently the values that a track can interpolate are <code>real</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, and <code>quat</code>. Other value types, especially composite types, need to be composed out of multiple tracks.</p></li><li><p><code>clip</code><br>A clip is a collection of tracks. Clips retain whether they should <code>loop-p</code> or not, and can be <code>name</code>d. When a clip is <code>sample</code>d, the target object passed should be a sequence, table, or object that can be indexed into by the <code>name</code> of the <code>tracks</code> in the clip.</p></li><li><p><code>pose</code><br>A pose is a collection of <code>transform</code>s for a skeleton. It represents a particular state for certain bones in the skeleton to be in. It also allows convenient access to the <code>global-transform</code> of a particular joint, and computing the <code>matrix-palette</code> used to perform the skinning.</p></li><li><p><code>skeleton</code><br>A skeleton contains all the information necessary for the skinning process, namely a <code>bind-pose</code> and <code>inv-bind-pose</code>, a <code>rest-pose</code>, and a table for the <code>joint-names</code>.</p></li><li><p><code>morph-group</code><br>Encapsulates a set of morph targets and their weights for a mesh. This is exposed as a <code>weights</code> array, a set of <code>textures</code> that encode the vertex deformations for each mesh, and a <code>morph-data</code> buffer that holds the effective weights and indices of the morph targets to apply. When constructing a <code>morph-group</code>, you should pass the set of meshes that share the group as an initarg.</p></li><li><p><code>animated-mesh</code><br>This is a helper class that contains the mesh data such as the extracted <code>position-normals</code> and packed <code>vertex-data</code>. It can be used to perform <code>cpu-skin</code>ning if needed over the standard gpu-driven skinning method. It also holds a set of meshes that encode the morph targets of the mesh in <code>morphs</code>, along with the <code>model-name</code> that designates the larger morph group that the mesh is a part of. Finally it may hold an <code>initial-weights</code> array.</p></li><li><p><code>layer-controller</code><br>This mixin class implements the <code>update</code> method in such a way that extra animation poses can be layered onto the base pose. Layers can be added and removed via <code>add-layer</code> and <code>remove-layer</code>.</p></li><li><p><code>fade-controller</code><br>This mixin class implements smooth playback of animation clips and the transitioning between them. As such implements a base <code>update</code> method to animate the <code>pose</code>, and keeps track of possibly multiple fade targets, which can be added via <code>fade-to</code>. A base clip can also be immediately started via <code>play</code>.</p></li><li><p><code>morph-group-controller</code><br>Handles the creation of the appropriate <code>morph-groups</code> for all of the meshes in the model. Also provides the <code>update-morph-data</code> function to sync the data after animation updates the weights. To fetch the morph group for a mesh, use <code>find-morph</code>.</p></li><li><p><code>armature</code><br>A debug display to show poses and animation clips.</p></li><li><p><code>animated-entity</code><br>A base class for animated 3d models. Requires an <code>animation-asset</code> to be passed, but will take care of setting up everything else based on that asset. Is also a <code>fade-controller</code>, <code>layer-controller</code>, and <code>morph-controller</code> so that animation clips can be easily used with the entity.<br>Note that it does not handle rendering of the mesh, only the vertex deformation needed to perform the animation.</p></li></ul><p>When loading stuff from a model file you will not have to worry about any of the underlying stuff. All you need is an <code>animated-entity</code> and an asset to load the model with. From there you can just <code>play</code>, <code>fade-to</code>, and <code>add-layer</code>/<code>remove-layer</code> to manage your animations on the entities.</p><h2 id="animated-assets">Animated-Assets</h2><p>In order to use the animation pipeline from model files, the model format system needs to provide a subclass of the <code>animation-asset</code>. Currently the only format that supports this is the <code>trial-gltf</code> importer.</p><p>Using one should be as simple as this:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-asset (workbench model) model-file
    #p&quot;model.gltf&quot;)

(make-instance 'animated-entity :animation-asset (asset 'workbench 'model))</pre></code><p>Once loaded the asset must contain a <code>skeleton</code>, a hash table of <code>clips</code>, and a hash table of <code>meshes</code>. The <code>animated-entity</code> will automatically extract and reference the properties as needed when you <code>play</code>, <code>fade-to</code>, etc.</p><p>Trial will also parse out the following extra animation properties from the model, if supported:</p><ul><li><p><code>next</code> [string] The name of the clip to play after this.</p></li><li><p><code>loop</code> [boolean] Whether to loop this clip or not. Defaults to true if unset. If <code>next</code> is set, this will be false.</p></li><li><p><code>forward-kinematic</code> [boolean] Whether this clip is forward-kinematic or not. If it is, then the root motion will be turned into physical movement instead.</p></li><li><p><code>velocity-scale</code> [float] The scale of the root motion when the clip is set to be forward-kinematic.</p></li><li><p><code>blocking-p</code> [boolean] Whether the animation should block from being switched away from.</p></li><li><p><code>blend-duration</code> [float] The default duration to use when <code>fade-to</code> on this clip is called.</p></li></ul><h2 id="defining clips">Defining Clips</h2><p>Aside from the fully automated import of animations and skins from model files as used with the <code>animated-entity</code>, you can also programmatically define animation clips to animate other properties and features.</p><p>To do so, use <code>define-clip</code> which has the following general structure:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-clip sandstorm
       (strength speed)
  0.0   0.0      (vec 0.0 0.0)
  1.0   0.8      (vec 0.2 0.0)
  1.5   _        (vec 1.0 0.0)
  2.0   1.0      _)</pre></code><p>Wherein <code>_</code> is used to omit a track from a keyframe. By default track interpolations are set to <code>:linear</code>. If you specify <code>:hermite</code> or <code>:cubic</code> for a track, you must wrap each keyframe value in a list to pass the extra values needed for the interpolation handles.</p><p>Once a clip is defined, you can retrieve it by its name via <code>clip</code> and use <code>sample</code> to apply the track's effects to an object that contains the properties to be animated.</p><p>Note that in general <code>sample</code> is modifying, meaning it updates the values in place to avoid producing garbage.</p><p>Animation clips are only meant for tweening properties. There is no support for evaluating functions at certain times or running other more complex code. If you need a system to put together sequences of actions and other such changes, please have a look at <a class="external-link" href="https://shinmera.github.io/action-list">action-lists</a>. They are trivial to integrate with Trial and are geared for that use.</p><h2 id="morphs / shape keys">Morphs / Shape Keys</h2><p>In addition to rigged animation, Trial also allows animation or deformation based on shape keys. In order to make use of morphs, you should use the <code>morphed-entity</code>. This entity holds a vector that adds the respective <code>morph-group</code> and data texture to each of the <code>vertex-arrays</code> of the entity.</p><p>When rendering a vertex-array, you must use the same index of the vertex-array to retrieve the respective morph data cell in the <code>morphs</code> vector. The car holds the <code>morph-group</code> of which you should <code>bind</code> the <code>morph-data</code> buffer to the <code>shader-program</code>, and the cdr holds the texture that you should <code>bind</code> to the <code>morph_targets</code> uniform. The <code>basic-animated-entity</code> takes care of all of this logic for you.</p><p>In order to control the weights, you can setf the respective entry in the <code>morph-group</code>s <code>weights</code> array. All weights should be single-floats in the range [0,1]. After setting them, you should <code>update-morph-data</code> to refresh the buffer.</p><p>Weights can also be animated via a <code>weights-track</code>. When setting its <code>frames</code>, it expects a values array that is longer than the times array. Frame values for the different morph targets are stored interleaved, meaning for instance for a linear interpolation track with two morph targets, the values should be</p><code style="display:block" class="code-block"><pre>frame0_morph0 frame0_morph1 frame1_morph0 frame1_morph1 ...</pre></code><p>When <code>sampling</code> from the track you should either pass an array of weights to animate, or a <code>pose</code> in which case the weights array corresponding to the track's <code>weights</code> in the pose is updated. In either case the array must be present and must match in length to the number of morph targets that the track expects. Usually you'll want to use the <code>weights</code> array of the corresponding <code>morph-group</code> instance.</p></article></body></html><link rel="stylesheet" href="highlight-lisp.css"><script type="text/javascript" src="highlight-lisp.js"></script><script type="text/javascript">[...document.querySelectorAll('[data-language="common lisp"] pre')].map(HighlightLisp.highlight_element);</script>