<!DOCTYPE html><html><head><title>Trial / Render Pipeline System</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="This document outlines Trial's render pipeline system and details how rendering behaves internally and externally."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Render Pipeline System"><meta property="og:url" content="https://shirakumo.org/docs/trial/render-pipeline.mess.html"><meta property="og:description" content="This document outlines Trial's render pipeline system and details how rendering behaves internally and externally."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="render pipeline system">Render Pipeline System</h1><p>This document outlines Trial's render pipeline system and details how rendering behaves internally and externally.</p><h2 id="1. parts">1. Parts</h2><p>The system deals with objects of the following types:</p><ul><li><p><code>container</code><br>Containers that are not themselves renderable, but may contain other renderables and provide positioning information.</p></li><li><p><code>renderable</code><br>An object to be drawn in the scene in some way. It is not specified how this object is drawn.</p></li><li><p><code>shader-pass</code><br>A rendering pass. Note that one pass may draw many objects, or none, such as for a post-processing pass.</p></li><li><p><code>shader-pipeline</code><br>A bundle of shader passes into a consistent pipeline that produces a set of textures or, more typically, renders to the screen.</p></li></ul><h2 id="2. lifecycle">2. Lifecycle</h2><p>In order to understand rendering, we have to look at two distinct cases where the renderer needs to change its state:</p><ol><li value="1"><p>Setup<br>After the scene is set up all of the renderable objects contained within need to be registered with the shader pipelines, so that effective shader programs can be computed and allocated. This typically occurs as a bulk change within a loading context.</p></li><li value="2"><p>Runtime</p><p>While the game is running, dynamic changes may add or remove renderable entities. Renderables may also come in or out of view, or for other reasons start or stop rendering. In this case the shader pipelines need to adapt appropriately to cull their draw calls.</p></li></ol><p>To actually perform the rendering, each shader pipeline simply iterates through each shader pass in topological order. Each pass then conceptually proceeds as follows:</p><ol><li value="1"><p>Allocate the objects that should be rendered for the current frame in a frame sequence:<br>1. If the frame is considered not to have changed, skip<br>2. For every <code>renderable</code> that is tied to the pass:</p><p>1. If the renderable is considered visible within the pass' context (may be culled for occlusion, frustum, or other reasons):</p><p>1. Store the object and its <code>shader-program</code> for the pass in the frame</p><p>3. Sort the frame to ensure objects are drawn in the correct order</p></li><li value="2"><p>Perform the render operations needed to render the frame:</p><ol><li value="1"><p>Bind the pass' textures</p></li><li value="2"><p>Iterate over the <code>renderable</code>s in order of the frame:</p><ol><li value="1"><p>Bind the object's textures and transforms</p></li><li value="3"><p>Call <code>render</code> with the associated <code>shader-program</code></p></li></ol></li></ol></li></ol><p>Important to note here are that <code>construct-frame</code> is called <em>for every frame</em>, meaning the potential culling and ordering is called automatically once per frame to ensure consistency. Passes may <em>elide</em> changing the frame, but by default without optimisations they will not.</p><p>Additionally, only <code>renderables</code> that are tied to the pass will be considered for rendering within the pass' context <em>at all</em>. Meaning that any object first needs to be tied to the pass by <code>enter</code>ing it. An object may also be dynamically removed by using <code>leave</code>.</p><p>A pass only distinguishes between 1. Setup and 2. Runtime above by whether a <code>container</code> is passed to the pass or a single <code>renderable</code>. Entering and leaving renderables potentially causes allocations to happen, as new shader programs may need to be compiled. More details on this are illustrated in ยง3.</p><p>The specifics of frame construction and rendering are elaborated upon in ยง4.</p><h2 id="3. allocation">3. Allocation</h2><p>Broadly passes are distinguished in the following manner:</p><ol><li value="1"><p>Post-processing passes<br>These passes contain all the rendering logic they need in themselves. The scene graph does not interact with them at all.</p></li><li value="2"><p>Per-object passes</p><p>These passes share some rendering logic with objects from the scene graph, and render control usually lies with the actual objects, rather than with the pass itself.</p></li></ol><p>For passes of type 1 there isn't much to discuss. The pass manages its own shader and geometry logic, and allocates that at the beginning when the pass data in general is allocated.</p><p>For type two, things are more interesting, as the pass needs to potentially allocate a shader program for the object, and needs to appropriately manage the lifetime of this program. The pass also needs to figure out the &quot;effective shader sources&quot; for each object tied to it.</p><p>When an object is <code>enter</code>ed into a pass, whether on its own or through a <code>container</code>, it proceeds as follows:</p><ol><li value="1"><p>If the object is already in the renderable table, skip</p></li><li value="2"><p>Check if the object's class has an allocated shader program. If not:</p><p><em>Note that this test always fails if the object is a <code>dynamic-renderable</code></em></p><ol><li value="1"><p>Construct a shader program calling <code>make-pass-shader-program</code>, which:<br>1. For each shader type:</p><p>1. Call <code>compute-shader</code> with the shader type, the pass, and the object<br>2. If the list of shaders returned is not empty:<br>3. Merge the list of shaders with GLSL-toolkit and construct the <code>shader</code> object</p><p>2. Merge the list of effective buffers for both pass and object<br>3. Construct the shader program using the list of <code>shader</code>s and <code>buffer</code>s</p></li><li value="2"><p>Check if an identical shader program exists. If not:</p><ol><li value="1"><p>Generate the shaders and shader program</p></li><li value="2"><p>Associate a load trigger with the program to run <code>update-uniforms</code> once loaded</p></li></ol></li><li value="3"><p>Tie the object's class to the generated shader program</p></li></ol></li><li value="3"><p>Increase the refcount of the shader program</p></li><li value="4"><p>Associate the object with its shader program in the renderable table</p></li></ol><p>If the object was entered on its own, the staging area is now committed. Otherwise the commit is deferred until all resource construction is complete. Note that this process is <em>very</em> cheap for instances of classes that have already been entered once before.</p><p>When an object is entered from a collection, it also first calls <code>object-renderable-p</code> on the object and pass, to preemptively cull objects that should not be rendered on the given pass.</p><p>When an object <code>leave</code>s a pass, it proceeds as follows:</p><ol><li value="1"><p>If an associated shader program is found in the renderable table:<br>1. Reduce the refcount of the associated shader program<br>2. Remove the object from the renderable table</p></li></ol><p>Deallocation of shader programs is <em>not</em> done even if the refcount reaches zero, as this could lead to bad dynamic allocations in the future when the same object type is entered again, such as can often happen for effects or other dynamic object types.</p><p>Instead, deallocation is deferred to when the pass is next <code>stage</code>d, at which point the programs with a zero refcount are culled again, and not staged, leading to a deallocation on commit.</p><h2 id="4. rendering">4. Rendering</h2><p>The rendering for post-processing passes is fairly straight-forward, simply calling <code>render</code> on the pass itself with the singular <code>shader-program</code> it has allocated for its operations.</p><p>Things only become interesting for per-object passes, as they first need to construct a sequence according to which the objects are rendered, and which also excludes objects that should be culled for the current frame. As described briefly in ยง2, this proceeds in two steps, in the first building the frame sequence, and in the second actually rendering that sequence.</p><p>In the first step, <code>construct-frame</code> is called, which proceeds as follows:</p><ol><li value="1"><p>If entities were added or removed, or visibility state of entities changed:<br><em>The visibility check especially is dependent on the specific rendering pass used and the camera model used. In many cases, recomputing the frame can be avoided as visibility of entities does not change frequently</em><br>1. Call <code>map-visible</code> on the pass' <code>camera</code> and <code>scene</code>, and iterate over every visible object:</p><p>1. If the object has an entry in the renderable table:</p><p>1. Store the object and its <code>shader-program</code> for the pass in the <code>frame</code></p></li><li value="3"><p>Sort the <code>frame</code> by the <code>sort-frame</code></p><p><em>The specifics of how this sorting occurs is up to the pass internals, but suffice to say that in most cases the cost can be held down a lot, and in cases where it's clear that order has not changed ahead of time, elided completely</em></p></li></ol><p>Most of the magic here is in the function <code>map-visible</code>. However, the precise operation of this is up to the individual camera models, which know how to properly perform frustum culling. The pass may also specialise <code>camera</code> to return <code>NIL</code> in order to iterate over every object in the <code>scene</code>, and/or specialise <code>scene</code> to return the pass itself in order to iterate over every object that was <code>enter</code>ed into the pass. Doing so can be useful to handle rendering of objects not part of the scene graph, or objects that would by default be culled from visibility.</p><p>In the second step, <code>render-frame</code> is called, which proceeds as follows:</p><ol><li value="1"><p>Call <code>bind-textures</code> on the pass<br><em>This causes necessary texture units that the pass needs in its shader fragments to get bound appropriately. We only have to do this once per pass, so best to do it here</em></p></li><li value="2"><p>Iterate over the <code>renderable</code>s in order of the <code>frame</code>:</p><ol><li value="1"><p>Call <code>apply-transforms</code><br><em>This sets up the transform matrices as required for the specific object in play. The transform matrices are reset to their prior values after each object completes its render step</em></p></li><li value="2"><p>Call <code>bind-textures</code></p><p><em>Same as before, but this time the object's textures are bound</em></p></li><li value="3"><p>Call <code>render</code> with the associated <code>shader-program</code></p><p><em>This performs the actual draw call, as well as any potentially needed setting of uniforms and so forth. Note that the setting of </em>many<em> uniforms should not be done here, as the uniforms are set once per frame per object, and many of the uniform values do not change that frequently</em></p></li></ol></li></ol><p>For per-object-passes, <code>render-frame</code> is called as part of the pass' <code>render</code> method, after which the pass may perform extra steps, such as blitting the framebuffer to the screen.</p></article></body></html>