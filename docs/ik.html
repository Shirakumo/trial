<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="inverse kinematics">Inverse Kinematics</h1><p>In addition to the &quot;forward kinematics&quot; system described in the <a class="external-link" href="animation.html">animation</a> section, Trial also offers inverse kinematics solvers that can be blended into the existing animation sets.</p><p>An inverse kinematics system is composed of an &quot;ik chain&quot;: a linked chain of joints that we want to make reach for a certain goal, while subject to a number of constraints. This chain as well as the strategy by which the kinematics are solved are handled by an <code>ik-solver</code>, of which Trial currently the following:</p><ul><li><p><code>ccd-solver</code><br>A simple solver that attempts to rotate joints to reach for the goal.</p></li><li><p><code>fabrik-solver</code><br>A solver that attempts to move joints to reach for the goal. Usually leads to more believable-looking results for animals and should be preferred.</p></li></ul><p>Every solver keeps a vector of the joint indices that are involved in the <code>ik-chain</code>, and a reference to the <code>pose</code> that contains the actual joint transforms. It also holds a vector of <code>ik-constraint</code> instances in its <code>constraints</code>, which are used to determine the limits to which the solver is allowed to push the transforms.</p><p>An <code>ik-constraint</code> is a simple object which only needs to implement the <code>apply-constraint</code> function, responsible for correcting the indicated joint to the acceptable range of motion. Currently the following constraint types are implemented: </p><ul><li><p><code>ball-socket-constraint</code><br>Implements a constraint similar to a hip joint, where the joint can rotate around an <code>axis</code>, but limited in its bending motion around that axis up to <code>limit</code>.</p></li><li><p><code>hinge-constraint</code><br>Implements a swivelling joint, where motion is constricted to follow around the <code>axis</code>, optionally also constraining the allowed angles to be within <code>min-angle</code> and <code>max-angle</code> (both in radians).</p></li></ul><p>An <code>ik-solver</code> itself must only implement the <code>solve-for</code> function, which should update the transforms in the <code>pose</code> to aim for the <code>goal</code> passed to the function. It is expected that each solver implements its strategy in an iterative manner, and returns true if the goal was reached, <code>NIL</code> if not. The iteration can be controlled via the <code>iterations</code> and <code>threshold</code> fields.</p><p>To construct a solver instance in a convenient manner the <code>ik-from-skeleton</code> function exists, which takes the name of a target <code>leaf-joint</code> (the joint that will try to reach for the target), and either a <code>length</code> or a <code>root-joint</code> that defines the length of the chain. This function will construct the correct joint sequence from the skeleton's pose and create the requested solver.</p><p>In order to actually manage the <code>solver</code> and the current <code>target</code> we have a controlling <code>ik-system</code>, which keeps track of the current blend <code>strength</code>, its <code>active-p</code> status, and a local <code>tf</code> transform.</p><p>The system must only implement the <code>update</code> function, which will update its internal <code>target</code> vector, transform it into local space, and then use <code>solve-for</code> to update the pose. Some handy subclasses exist as well:</p><ul><li><p><code>global-ik-system</code><br>Simply aims the solver towards a <code>global-target</code> vector at all times.</p></li><li><p><code>clip-ik-system</code><br>Uses a <code>clip</code> to animate the target (and possibly other properties) over time.</p></li><li><p><code>entity-target-ik-system</code><br>Aims towards the location of another <code>entity</code> with an <code>offset</code>.</p></li></ul><p>Each system still only controls <em>one</em> solver and thus one IK chain.</p><p>To bring this all together and to allow multiple chains to be used at once, the <code>ik-controller</code> mixin class exists. It keeps a number of named <code>ik-systems</code>, updates them all together, and blends their results into the final <code>pose</code>. It also presents an easier interface to manage the systems with <code>add-ik-system</code>, <code>remove-ik-system</code>, and the <code>ik-system</code> accessor.</p><p>The basic <code>animated-entity</code> and <code>armature</code> include an <code>ik-controller</code>, meaning you can directly add IK chains onto those and control them that way.</p></article>