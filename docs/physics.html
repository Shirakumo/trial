<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="physics in trial">Physics in Trial</h1><p>Trial contains a basic protocol for implementing physics systems, which is described in this document. The <a class="external-link" href="mass-aggregate.html">mass aggregate</a> and <a class="external-link" href="rigid-body.html">rigid body</a> systems make use of this protocol.</p><h2 id="entities">Entities</h2><p>All objects that can be controlled by a physics system must be a subclass of <code>physics-entity</code>, which keeps track of the <code>velocity</code>, <code>inverse-mass</code>, the currently accumulated <code>forces</code>, the <code>damping</code> factor, and its <code>awake-p</code> status. You can also access the <code>mass</code>, which will translate to/from the more commonly used <code>inverse-mass</code>.</p><p>The <code>awake-p</code> status controls whether the object is currently being updated or not, and is usually automatically controlled by the physics system. However, if you require an object to be permanently awake, you can also add a method that always returns <code>T</code>.</p><p>Every physics entity implements <code>current-motion</code>, which returns a scalar representing the energy of its current motion, which is used to control the sleep status.</p><p>Like the properties of other helper classes, setting the <code>velocity</code> or <code>force</code> will not retain the identity of the vectors passed in, and instead update the vectors held by the entity. Adding velocity or forces can simply be done like usual with <code>nv+</code>.</p><p>Finally, any physics entity must implement <code>integrate</code> and <code>start-frame</code>. The former is called at the beginning of any system's update step, and allows clearing out any remaining forces. The <code>integrate</code> function on the other hand is responsible for updating the accumulated forces and integrating the motion over the given timestep, advancing the object.</p><h2 id="forces">Forces</h2><p>Common to all physics systems is also the description of <code>force</code>s. A force is something that automatically adds or removes forces on physics entities. A force must only support a single function, <code>apply-force</code> which updates the passed entity accordingly. Note that entities with infinite mass will never receive any forces.</p><p>The following primitive forces are supplied:</p><ul><li><p><code>gravity</code><br>A constant force in a constant direction.</p></li><li><p><code>drag-force</code><br>A force to simulate drag slowing the object down. Uses the <code>k1</code> and <code>k2</code> drag coefficients.</p></li><li><p><code>spring-force</code><br>A spring tying an object to an <code>anchor</code> with the spring fastened at <code>anchor-offset</code>, and <code>local-offset</code> on the object's end. The spring has a <code>rest-length</code> and a <code>spring-constant</code>. Note that this force generator does not behave well for stiff springs.</p></li><li><p><code>stiff-spring-force</code><br>A special spring type more suited towards very stiff springs. Has the same properties as the <code>spring-force</code>, but instead of a rest length has a <code>damping</code> factor, with the rest length always being zero.</p></li><li><p><code>bungee-force</code><br>Another variant of a <code>spring-force</code>, but only acting for expansion, not compression.</p></li><li><p><code>located-force</code><br>Mixin class for forces that have a <code>location</code>.</p></li><li><p><code>spherical-force</code><br>Mixin class for forces that have a spherical <code>radius</code> of influence.</p></li><li><p><code>aabb-force</code><br>Mixin class for forces that have an axis-aligned bounding box <code>bsize</code> of influence.</p></li></ul><h2 id="contacts">Contacts</h2><p>Core to all physics systems is also the handling of contacts. We provide a base structure class called <code>hit</code>, which stores the two objects involved in the contact, <code>a</code> and <code>b</code>, the <code>location</code> of the contact, the <code>normal</code> (from the perspective of <code>a</code>), the <code>restitution</code> describing the &quot;bounciness&quot; of the contact, the <code>static-friction</code> and <code>dynamic-friction</code> between the two objects' materials, and the <code>depth</code> of the contact's intersection.</p><p>You may, like the rigidbody system, construct a subtype of this <code>hit</code> class to extend it with other useful properties as necessary.</p><h2 id="controlling systems">Controlling Systems</h2><p>Physics entities alone are not enough. Everything is tied together through a <code>physics-system</code> which is responsible for controlling the forces, contacts, and the integration. An entity should only ever be a part of a single physics system, but you might have several independent systems to control simulations that don't interact with each other.</p><p>Every system holds a set of forces and a set of objects under its control. You can add and remove either with the standard <code>enter</code> and <code>leave</code> functions. Aside from this, every system also holds a cache of <code>hits</code> used for contact resolution, and the <code>sleep-eps</code> that defines the minimum amount of motion below which an object is put to sleep.</p><p>When initialising a system, you can pass <code>units-per-metre</code> which informs the system about the relative scale of your object, allowing it to automatically tune any parameters for your setup.</p><p>A system must implement <code>generate-hits</code>, which fills the passed vector of hits with new contacts and returns the updated start offset. It must also implement <code>resolve-hits</code>, which will then resolve any collisions described in the hits vector. These functions may be called multiple times per update, in order to generate and resolve hits for distinct sets of contacts. The precise calling behaviour is up to the physics system.</p><p>Calling <code>integrate</code> on a system will cause it to integrate the motion of any of the objects it controls, and manage the sleep state thereof.</p><p>Finally, the basic physics system also provides an <code>update</code> entry function, which will apply all forces generated to all of its objects, integrate the system, and then generate and resolve any contacts. If your system requires more precise control over this process, you should define a method to override it.</p><p>The <code>physics-system</code> is also an <code>entity</code> and <code>listener</code> such that it can simply be added into a <code>scene</code> and automatically manage the timesteps.</p><h2 id="material properties">Material Properties</h2><p>Trial ships a small library of known material property constants. These constants describe how two different materials interact with each other, which is used in collision resolution. To access the properties structure, use <code>material-interaction-properties</code> on a set of materials, usually named by keywords.</p><p>The property holds the materials (<code>a</code> and <code>b</code>), the <code>static-friction</code> and <code>dynamic-friction</code> factors, and the <code>restitution</code> (see &quot;Contacts&quot;).</p><p>You can list the known interactions with <code>list-material-interaction-properties</code>. If a material you would like to use is not provided by default, you can add it with <code>set-material-interaction-properties</code> (and send us a PR!)</p><p>You may also set the <code>*default-material-interaction-properties*</code> which is used if the system attempts to look up any properties that aren't defined explicitly.</p><h2 id="inertia tensors">Inertia Tensors</h2><p>Rigid and soft body physics require some kind of description of the resistance towards rotation of the object. This is typically encompassed via a 3x3 matrix called the inertia tensor. Trial provides a number of functions to automatically compute this tensor for your collision primitives.</p><p>A new tensor computation function is defined via <code>define-tensor-fun</code>, which automatically defines a common function signature and gives you access to the tensor's local fields through the <code>m</code> local function.</p><p>Trial currently provides the following tensor computation functions:</p><ul><li><p><code>mass-aggregate-tensor</code><br>The particles must be a vector of objects with a <code>location</code> and a <code>mass</code>. The tensor is then computed using this particle mass distribution description.</p></li><li><p><code>box-tensor</code><br>Tensor for a box with uniform weight distribution.</p></li><li><p><code>sphere-tensor</code><br>Tensor for a sphere with uniform weight distribution.</p></li><li><p><code>shell-tensor</code><br>Tensor for a hollow sphere with uniform weight distribution.</p></li><li><p><code>cylinder-tensor</code><br>Tensor for a cylinder with uniform weight distribution.</p></li><li><p><code>tube-tensor</code><br>Tensor for a hollow tub with uniform weight distribution.</p></li><li><p><code>cone-tensor</code><br>Tensor for a cone with uniform weight distribution.</p></li></ul><p>We currently do not have any functions to automatically combine tensors or compute tensors for complex shapes. Please help us out by adding more!</p></article>