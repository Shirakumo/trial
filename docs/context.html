<article><style>article{
    max-width: 800px;
    font-size: 12pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
}</style><h1 id="render contexts">Render Contexts</h1><p>Trial is &quot;backend agnostic&quot; in that it can work with several underlying libraries to handle the OpenGL context and window management. The standard and most well-tested backend is the GLFW integration through trial-glfw.</p><p>Typically, management of the context is handled by <code>main</code> and the associated <code>launch</code>. For highest convenience, you'll probably just want to create your own wrapper around <code>launch</code> that passes the appropriate arguments for context construction via the <code>:context</code> initarg.</p><h2 id="context objects">Context Objects</h2><p>The context combines both a window and an OpenGL context, treating them as the same. It is expected that games do not utilise multiple windows, instead using virtual windows within the main game window if required.</p><p>There may be multiple context instances in flight at once, in order to allow asynchronous upload of resources such as textures through shared contexts in background threads. However, there can only be one primary context in flight at a time, and only one context of any kind can be current to any one thread at a time.</p><p>In order to issue OpenGL commands, an appropriate context must be current on the thread. Many commands are only available on the primary context. Typically you will only need one context, and with the <code>render-loop</code> class, all the drawing will be contained on one thread anyway.</p><p>The base context object has a rather wide API to interact with. The context itself has a <code>handler</code> to which it sends events whenever input or other changes come along. Typically the handler will be a <code>main</code> instance, which then sends the events along to the scene for delivery. See the <a class="external-link" href="event-loop.html">event-loop</a>.</p><h3 id="context interaction">Context Interaction</h3><ul><li><p><code>*context*</code> Accesses the current context</p></li><li><p><code>make-context</code> Create a new context instance. Should be used to construct shared contexts</p></li><li><p><code>launch-with-context</code> Should be called to launch <code>main</code> with a valid primary context instance</p></li><li><p><code>destroy-context</code> Destroy the context and make it unusable. Frees all GL resources</p></li><li><p><code>valid-p</code> Whether the context is still valid and thus usable at all</p></li><li><p><code>make-current</code> To make the context current in this thread. Post this, GL commands may be used. Beware of stealing the context from another thread, use <code>with-context</code> for safe management</p></li><li><p><code>done-current</code> To free the context up from this thread. Post this, no GL commands may be used</p></li><li><p><code>current-p</code> Whether the context is current in this thread</p></li><li><p><code>with-context</code> Invoke body with the context bound locally. Ensures proper context sharing</p></li><li><p><code>profile</code> What profile is used. Should be one of: <code>:core :compatibility :es NIL</code></p></li><li><p><code>version</code> The major and minor version of OpenGL as a list of two elements</p></li></ul><h3 id="window interaction">Window Interaction</h3><p>Note that these functions may be no-ops on some backends where the concept of a &quot;window&quot; does not apply.</p><ul><li><p><code>hide</code> Hides the window</p></li><li><p><code>show</code> Makes the window visible, changes its fullscreen behaviour, and video mode</p></li><li><p><code>visible-p</code> Whether the window is currently visible or not</p></li><li><p><code>resize</code> Resize the window. Typically you want to use <code>show</code> with a video mode instead</p></li><li><p><code>quit</code> Closes the window and shuts things down</p></li><li><p><code>show-cursor</code> Ensure the OS cursor can be seen</p></li><li><p><code>hide-cursor</code> Hides the OS cursor turning it invisible</p></li><li><p><code>lock-cursor</code> Locks the OS cursor within the window preventing it from escaping. Use with care to prevent over-eager cursor capture</p></li><li><p><code>unlock-cursor</code> Unlock the OS cursor allowing it to escape the window</p></li><li><p><code>cursor-position</code> Return the current cursor position within the window</p></li><li><p><code>title</code> Access the title shown on the window</p></li><li><p><code>vsync</code> Access whether vertical screen synchronisation is in effect</p></li><li><p><code>width</code> Return the window's current width in pixels</p></li><li><p><code>height</code> Return the window's current height in pixels</p></li></ul><h3 id="system interaction">System Interaction</h3><p>Some interactions with the rest of the operating system are also provided:</p><ul><li><p><code>clipboard</code> Access the clipboard contents. A context must, in the very least, support strings, but may also support arbitrary octet vector content</p></li><li><p><code>local-key-string</code> Return the name of the key in the current layout for the given scan-code. Meaning if the user has, say, a Dvorak layout, the scan-code <code>:t</code> will yield <code>&quot;y&quot;</code>. You should use this function whenever you intend to display a key prompt to the user.</p></li></ul><h3 id="video modes and monitors">Video Modes and Monitors</h3><p>One important part is the handling of &quot;video modes&quot; or screen resolution and refresh rate. Trial defines a video mode &quot;structure&quot; as a list composed out of: <code>(width height [refresh-rate [display-descriptor-string]])</code>.</p><p>A user may have multiple monitors connected, and the available list of video modes for each may be different. To list the available monitors, use <code>list-monitors</code>, and the current monitor the window is on can be retrieved with <code>current-monitor</code>.</p><p>The monitor structure is backend-dependent, but must support getting its string <code>name</code>. To get the monitor back from its name, use <code>find-monitor</code>. If the monitor has since been removed or is not present, it may not be returned even with a valid name.</p><p>To get the video modes available, use <code>list-video-modes</code>. To activate one, pass the mode to <code>show</code>. If the mode came from a monitor listing, it will include the monitor's name, ensuring that the window will be shown on the correct monitor.</p><h3 id="events">Events</h3><p>Aside from the keyboard and mouse <a class="external-link" href="input.html">input events</a>, the context is also responsible for sending the following events:</p><ul><li><p><code>resize</code> After the window has changed size. Typically requires updating camera and UI</p></li><li><p><code>lose-focus</code> After the window has lost focus. May be useful to pause the game</p></li><li><p><code>gain-focus</code> After the window has received focus. May be useful to unpause the game</p></li><li><p><code>window-hidden</code> After the window has been hidden or minimised</p></li><li><p><code>window-shown</code> After the window has been restored from being hidden or minimised</p></li></ul><h2 id="context management">Context Management</h2><p>Typically managing a context directly is cumbersome and a lot of extra scaffolding is needed. The first part is the <code>render-loop</code>. On its own, the render loop does not care about a context at all. ALl it does is, after being <code>start</code>ed, it maintains a thread that calls <code>update</code> and <code>render</code> on the loop in regular intervals â€“ fixed timestep intervals for <code>update</code> and as much as possible under the constraints of frame limits and such for <code>render</code>.</p><p>The <code>display</code> as a render-loop upgrade then ties the loop behaviour to an actual context instance, manages the cleanup and setup of the context, and so on. It introduces <code>setup-rendering</code> for initial setup of GL attributes and modes.</p><p>Finally, the <code>main</code> instance ties everything together with a <code>scene</code> for event management, and a <code>loader</code> for resource management (see <a class="external-link" href="resources.html">resources</a>). This is typically what you want to subclass for your own games, as it provides most of the convenience and is required for many of the other integrations with other subsystems.</p></article>