<!DOCTYPE html><html><head><title>Trial / Shaders and You!</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Trial is based upon OpenGL and as such uses the GLSL language for writing shaders. While you can directly create shader instances and then compile them to a shader-program, the more typically intended user interface is through shader-entity classes, which are defined via define-shader-entity."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Shaders and You!"><meta property="og:url" content="https://shirakumo.org/docs/trial/shaders.mess.html"><meta property="og:description" content="Trial is based upon OpenGL and as such uses the GLSL language for writing shaders. While you can directly create shader instances and then compile them to a shader-program, the more typically intended user interface is through shader-entity classes, which are defined via define-shader-entity."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="shaders and you!">Shaders and You!</h1><p>Trial is based upon OpenGL and as such uses the GLSL language for writing shaders. While you can directly create <code>shader</code> instances and then compile them to a <code>shader-program</code>, the more typically intended user interface is through <code>shader-entity</code> classes, which are defined via <code>define-shader-entity</code>.</p><h2 id="shader entities">Shader Entities</h2><p>A <code>shader-entity</code> holds shader code fragments in its class, and can inherit shader code fragments from its superclasses. Trial will combine the shaders together automatically, such that shader semantics combine like other method semantics would in CLOS. More on that later. Defining a basic custom shader class is simple:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-shader-entity my-object (vertex-entity)
  ())

(define-class-shader (my-object :fragment-shader)
  &quot;out vec4 color;

void main(){
  color = vec4(0, 1, 0, 1);
}&quot;)</pre></code><p>The above defines a class that has a fragment shader attached, which sets the output colour to green. We inherit from <code>vertex-entity</code> which handles the loading and drawing of the mesh, and also provides the required vertex shader to process the vertices of the mesh and position them in space.</p><p>You can see the fully compiled shader with <code>compute-effective-shaders</code>:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(compute-effective-shaders (find-class 'my-object))

; ==&gt;
(:VERTEX-SHADER &quot;layout(location = 0) in vec3 position;
uniform mat4 model_matrix;
uniform mat4 view_matrix;
uniform mat4 projection_matrix;

void _GLSLTK_main_1(){
  gl_Position = (projection_matrix * (view_matrix * (model_matrix * vec4(position, 1.0))));
}

void main(){
  _GLSLTK_main_1();
}&quot;
 :FRAGMENT-SHADER &quot;out vec4 color;

void _GLSLTK_main_primary_1(){
  color = vec4(1.0, 1.0, 1.0, 1.0);
}

void _GLSLTK_main_1(){
  color = vec4(0, 1, 0, 1);
}

void main(){
  _GLSLTK_main_1();
}&quot;)</pre></code><p>Here you can see the vertex shader we inherited, and the fragment shader we defined as well, though slightly modified by the merging. It appears alongside the vertex shader, we already inherited another default fragment shader which sets the output colour to white. In this case we just override the result so it doesn't matter much, but if we need to prevent a superclass' shader fragment, we can inhibit it:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-shader-entity my-object (vertex-entity)
  ()
  (:inhibit-shaders (shader-entity :fragment-shader)))</pre></code><p>Looking at the effective shader for the class now, the inherited fragment is gone.</p><p>OpenGL offers many other shader types than fragment and vertex shaders, all of which you can attach to a shader entity in the same way. All of them can be specified with just raw GLSL code snippets. However, if so desired, you can also outsource the shader code into separate files, and then include them, instead:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-class-shader (my-object :fragment-shader)
  (pool-path 'my-project #p&quot;my-object.frag&quot;))</pre></code><p>Or you can include a shader file with multiple sections directly in the class definition:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(define-shader-entity my-object (vertex-entity)
  ()
  (:shader-file (my-project &quot;my-object.glsl&quot;)))</pre></code><p>With the file being sectioned like this:</p><code style="display:block" class="code-block" data-language="glsl"><pre>#section FRAGMENT_SHADER
out vec4 color;

void main(){
  color = vec4(0, 1, 0, 1);
}</pre></code><p>You can also include other files, or the <code>gl-source</code> of assets from your shader with a <code>#include</code>:</p><code style="display:block" class="code-block" data-language="glsl"><pre>#include (my-project:my-project &quot;my-other-shader.glsl&quot;)
#include (trial:trial trial:standard-environment-information)</pre></code><p>The acceptable include syntax being <code>(POOL PATH)</code>, <code>(POOL ASSET)</code>, <code>CLASS-NAME</code>, or <code>PATHNAME</code> where the path is relative to the current file.</p><p>There are currently no plans to include a more &quot;lispy&quot; syntax for writing shaders, though it isn't out of the question for such an inclusion to be made. Regardless, the raw GLSL approach will always be supported.</p><p>Trial however does make use of GLSL-Toolkit's &quot;method combination&quot; feature. If a function with the same signature is defined multiple times, the functions are renamed. That prevents inheriting multiple code parts from clashing. However, you can also call an earlier definition with <code>call_next_method();</code> or <code>maybe_call_next_method();</code>.</p><p>Better still, you can add a <code>@after</code>, <code>@before</code>, or <code>@around</code> to the end of your function name to denote the same qualifier as you'd understand for CLOS' standard method combination. Such functions will then combine as expected with the rest in the same shader. Using this you can create much more modular interfaces for shaders and extend or override parts in a far more controlled manner.</p><p>GLSL-Toolkit will also ensure that function signature declarations are inserted before any function definitions, allowing you to refer to any other function without having to worry about function definition ordering.</p><p>Due to the looseness of GLSL code, the automated combination of fragments can sometimes end up somewhat unpredictable. Especially if the shader fragments do not agree on the names of various variables. GLSL-toolkit will do its best to try and match up the variables and rename them to slot the pieces together, but it may not always be successful at doing everything fully automated.</p><p>Currently we don't have a specified shader interface system to help with this issue, but it is something that we would like to add at a later point. For now, simply look at whatever fragments you inherit, and check that your variable names align, should the merging miscompile.</p><p>Please also note that under the typical <a class="external-link" href="render-pipeline.html">render pipeline</a> the effective shader not only depends on the fragments of your class, but can also be further modified by the shader passes it is rendered by.</p><h2 id="uniforms">Uniforms</h2><p>Often you will want to pass extra information into a shader or configure parameters of it. This is usually done with uniform variables on the shader side, which are then set before the draw call is made. If you have such uniforms, you will often set them in a <code>update-uniforms</code> method like so:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(defmethod update-uniforms :after ((object my-object) program)
  (setf (uniform program &quot;whatever&quot;) 10.0))</pre></code><p>Note: setting uniforms that don't exist will quietly ignore, but trying to set a value that does not match the type of the uniform will error.</p><p>Trial support setting uniforms of type <code>int</code>, <code>float</code>, <code>double</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, <code>mat2</code>, <code>mat3</code>, <code>mat4</code>, and <code>matn</code>. For more complex structure types you have to either use <a class="external-link" href="buffers.html">uniform buffer objects</a>, or set each field of the structure individually by using its full name.</p><p>Sometimes uniforms don't change every frame and don't change for every object, and as such don't need to be updated with every <code>render</code>, either. In that case you have to gain access to the shader programs related to the entity via <code>shader-program-for-pass</code> and set the uniforms whenever they <em>do</em> change. However, this is usually an optimisation best left for later.</p><p>You can also more conveniently declare uniforms as slots, by adding the <code>:uniform</code> initarg to your slot definitions. If you specify <code>T</code>, the uniform name will be inferred via the <code>symbol-&gt;c-name</code> of the slot's name. Otherwise you can also directly specify the uniform name as a string. Note that this only takes care of <em>setting</em> the uniform value, not of declaring the uniform on the shader side.</p><h2 id="constants">Constants</h2><p>Similar to uniforms you can define shader constants as shader entity slots, by adding the <code>:constant</code> initarg to your slot definitions. If you specify <code>T</code>, the constant name will be inferred via the upcased <code>symbol-&gt;c-name</code> of the slot's name. Otherwise you can also directly specify the constant name as a string.</p><p>The constant is added to the relevant shaders via <code>compute-preprocessor-directives</code>, which is called by <code>make-class-shader-program</code> for a <code>shader-entity</code> instance, and by <code>make-pass-shader-program</code>. The definitions are added at the top, right after the <code>#version</code> directive. </p><p>Please note that by default a <code>per-object-pass</code> groups shader programs together by the <code>effective-shader-class</code> of the object, and uses that class to compute the shader program. Thus, slot constants defined on the object will <strong>not</strong> be visible in the resulting shader program.</p></article></body></html><link rel="stylesheet" href="highlight-lisp.css"><script type="text/javascript" src="highlight-lisp.js"></script><script type="text/javascript">[...document.querySelectorAll('[data-language="common lisp"] pre')].map(HighlightLisp.highlight_element);</script>