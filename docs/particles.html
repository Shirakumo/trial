<!DOCTYPE html><html><head><title>Trial / Particles</title><meta property="og:image" content="https://repository-images.githubusercontent.com/54314855/81c55af6-b2c4-45f0-b66d-f29fdd37be7f"><meta property="og:image:alt" content="Trial includes a high performance particle simulation system that performs almost all of the work on the GPU, allowing you to create particles with hundreds of thousands of particles (if needed)."><meta property="og:type" content="object"><meta property="og:title" content="Trial / Particles"><meta property="og:url" content="https://shirakumo.org/docs/trial/particles.mess.html"><meta property="og:description" content="Trial includes a high performance particle simulation system that performs almost all of the work on the GPU, allowing you to create particles with hundreds of thousands of particles (if needed)."></head><body><article><a class="index" href="index.html">Index</a><style>article{max-width:800px;font-size:12pt;font-family:sans-serif;margin:0 auto 3em auto;}article h1{text-align:center;font-size:2em;}article img{margin:0 auto;max-width:100%;}article blockquote{border-left:0.2em solid gray;margin-left:1em;padding-left:1em;}article figcaption{padding:0.2em 1em;background:#E0E0E0;}article code{background:#F0F0F0;padding:0 0.1em;}article .code-block{padding:0.1em 0.5em;overflow-x:auto;}article a.index{display:block;text-decoration:none;text-align:center;font-size:1.1em;background:#151515;border:2px solid #151515;color:#FEFEFE;}article a.index:hover{background:#FEFEFE;color:#151515;}</style><h1 id="particles">Particles</h1><p>Trial includes a high performance particle simulation system that performs almost all of the work on the GPU, allowing you to create particles with hundreds of thousands of particles (if needed).</p><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> This section refers to particles used for visual effects. For particles as used in physics simulations (Verlet, etc) see <a class="external-link" href="mass-aggregate.html">Mass Aggregate Physics</a>.</p></blockquote><figure><a href="images/particles.png" target="_blank"><img alt="images/particles.png" src="images/particles.png" style="display:block;"></a></figure><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> This system requires <span style="font-weight:bold">OpenGL 4.2</span> or later. Most of the engine is built around OpenGL 3.3, but that would proclude using Compute Shaders, which are required for this approach. In order to use these particle systems, make sure to construct your context with <code>:version '(4 2)</code>. If you want to run particles on OpenGL 3.3 see the <a class="cross-reference" href="#cpu simulation">section below</a>.</p></blockquote><p>In order to create a particle system, simply create a <code>gpu-particle-emitter</code> and enter it into a scene. You can then use <code>emit</code> to burst particles on demand, or set the <code>particle-rate</code> to create a continuous stream of particles.</p><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> In order for the system to work correctly you need a <a class="external-link" href="standard-renderer.html">standard renderer</a> derived renderer in your scene such as the <code>pbr-render-pass</code>. The particles aren't actually shaded by the renderer, but they require the environment information that the pass also takes care of providing.</p></blockquote><p>Particles have a variety of attributes that can be set either with the <code>:particle-options</code> initarg on the construction of the emitter, or using accessors:</p><ul><li><p><code>size</code><br>The size of the particle when it is created (affected by <code>:randomness</code>).</p></li><li><p><code>scaling</code><br>The scaling factor of the particle over its lifetime.</p></li><li><p><code>rotation</code><br>The rotation factor of the particle over its lifetime (affected by <code>:randomness</code>).</p></li><li><p><code>color</code><br>The multiplicative color mask of the particle. This must be a <code>vec3</code>.</p></li><li><p><code>randomness</code><br>The randomness factor. If 0 all particles will receive the same properties. This randomness also applies to the distribution of the origin of each particle over the emitter's surface.</p></li><li><p><code>velocity</code><br>The initial velocity of a particle when it is created (affected by <code>:randomness</code>).</p></li><li><p><code>lifespan</code><br>The default lifespan of a particle in seconds.</p></li><li><p><code>lifespan-randomness</code><br>The randomness factor applied to the particle's lifespan. This is separate from the other randomness factor.</p></li><li><p><code>mode</code><br>Can be either <code>:billboard</code> (default) or <code>:quad</code>. In the former case the sprite always faces the camera, whereas in the latter case it uses the emitter's model matrix and behaves as a normal quad otherwise. Please note that this also means that already emitted particles in quad mode will be influenced by changes to the emitter's transform.</p></li><li><p><code>flip</code><br>Can be either <code>NIL</code> (default) for no flipping, <code>:x</code> for horizontal flipping, <code>:y</code> for vertical flipping, or <code>T</code> for both. Whether the particle's texture is flipped or not is randomised subject to this flip option.</p></li><li><p><code>texture</code><br>The texture used for each particle's quad. Note that this is applied for every particle and a change also applies to already emitted particles.</p></li></ul><p>Besides the per-particle properties, the emitter itself also has a number of useful properties:</p><ul><li><p><code>vertex-array</code><br>This sets the surface across which particles are emitted. By default this is a unit square.</p><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> It must be a triangle mesh with position and normals and it must have an index buffer.</p></blockquote></li><li><p><code>location</code><br>The location of the particle emitter surface. Changing this will only affect particles that are emitted in the future (unless in <code>:quad</code> mode, see above).</p></li><li><p><code>orientation</code><br>The orientation of the particle emitter surface. Changing this will only affect particles that are emitted in the future (unless in <code>:quad</code> mode, see above).</p></li><li><p><code>scaling</code><br>The scaling of the particle emitter surface. Changing this will only affect particles that are emitted in the future (unless in <code>:quad</code> mode, see above).</p></li><li><p><code>particle-rate</code><br>The rate in particles per second that are emitted from this emitter.</p></li><li><p><code>to-emit</code><br>How many particles to emit on next tick. You should probably use the <code>emit</code> function instead.</p></li><li><p><code>motion-blur</code><br>If set to non-zero, particle quads will be stretched along their motion vector to simulate motion blur. Note that this will not actually interpolate positions, but may lend the illusion of motion blur due to the stretching of the texture.</p></li><li><p><code>local-threads</code><br>The number of local work group threads run on the GPU.</p><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> Setting this to too high a value may signal an error in development mode if the hardware does not support it. In release mode Trial will simply truncate the setting to the maximum allowed value. OpenGL only guarantees a value of up to 1024.</p></blockquote></li><li><p><code>max-particles</code><br>The maximum number of particles the emitter can display. This cannot be changed once the emitter has been created. Trying to create more particles than this will simply &quot;drop&quot; them. In order to set this you must pass it as an initarg.</p><blockquote><p><span style="color:rgb(255,0,0);font-weight:bold">NOTE:</span> There is a system maximum of particles that can be supported by the hardware. If <code>max-particles</code> is set higher than can be supported by <code>local-threads</code> and the underlying hardware, an error is signalled in development mode. In release mode Trial will simply truncate the setting to the maximum allowed value.</p></blockquote></li><li><p><code>particle-force-fields</code><br>See below</p></li></ul><p>Due to the high flexibility afforded by the emitter, you can probably re-use the same emitter to spawn particles in multiple places. To do so, simply use the <code>emit</code> function, which also allows you to conveniently place the emitter.</p><h2 id="force fields">Force Fields</h2><p>One of the factors that makes particles so fast is that they typically don't interact with the environment. However, it can still be useful to be able to make the particles be affected by various forces, whether to simulate gravity, wind, or other interactions.</p><p>To do so you can set the <code>particle-force-fields</code> on the emitter. This can either be a <code>shader-storage-buffer</code> backing a <code>particle-force-fields</code> structure, in which case the force fields can be shared between multiple emitters, or simply a list of force field descriptions to update the existing buffer. Each field should be a plist with the following attributes:</p><ul><li><p><code>:type</code><br>The type of field that is defined. Can be one of:</p><ul><li><p><code>NIL</code><br>Has no effect.</p></li><li><p><code>:point</code><br>A point field, with the strength being linear to the distance within its spherical range.</p></li><li><p><code>:direction</code><br>A directional field, exerting a constant force in its direction everywhere.</p></li><li><p><code>:plane</code><br>A planar field, with the force in the direction of the plane and the strength being linear to the distance within its spherical range.</p></li><li><p><code>:vortex</code><br>A vortex field, applying a tangential force along its normal, proportional to the distance from its centre normal.</p></li><li><p><code>:sphere</code><br>A field that simulates a smooth sphere. Particles that go within its spherical range are rebounded and receive a tangential force to cause them to &quot;slip&quot; off.</p></li><li><p><code>:planet</code><br>A gravitational field with infinite extent. If the range is positive, particles that would go within the spherical range receive a sphere force instead.</p></li></ul></li><li><p><code>:position</code><br>The world-space position of the field.</p></li><li><p><code>:strength</code><br>The &quot;strength&quot; of the field's force.</p></li><li><p><code>:range</code><br>The world-space range of the field if it has an extent.</p></li><li><p><code>:normal</code><br>The world-space normal vector if the field has a directionality.</p></li></ul><h2 id="collisions">Collisions</h2><p>If you would like your particles to bounce off of geometry, you can use a <code>depth-colliding-particle-emitter</code> and connect it to the render pass like so:</p><code style="display:block" class="code-block" data-language="common lisp"><pre>(connect my-standard-render-pass my-emitter-instance scene)</pre></code><p>Note that the bounce is determined directly from the depth buffer and not from real geometry, and as such anything that isn't visible from the camera's point of view will not cause the particles to bounce as expected.</p><h2 id="alpha blending">Alpha blending</h2><p>By default the emitter uses additive blending, which is a lot cheaper to simulate, as particles can be rendered in any order. If you require standard alpha blending for your particles, then you should use the <code>sorted-particle-emitter</code> instead, which runs a bitonic sort after simulation to ensure that all particles are drawn back to front.</p><h2 id="multiple textures">Multiple Textures</h2><p>The default emitter only allows using a single texture per particle. Sometimes it can be useful to vary the texture a little between particles. To do so you can use the <code>multi-texture-particle-emitter</code>, whose <code>texture</code> must be a <code>texture-2d-array</code>. You can then use this particle option to configure the sprite selection:</p><ul><li><p><code>sprite</code><br>The sprite index to be used. This is useful if multiple textures are attached and the displayed sprite should be a specific one. You may use up to 15 different sprites, or <code>:random</code> if it should be shuffled.</p></li></ul><h2 id="cpu simulation">CPU Simulation</h2><p>On systems with restricted GPU capabilities (GL 3.3) or for particle systems with a very small number of particles it can be more useful to simulate on the CPU instead of the GPU. In this case you can use the <code>cpu-particle-emitter</code>. The interface of the emitter is the same as for the <code>gpu-particle-emitter</code>, though it has one crucial difference: particles in both quad render modes can be spawned at different places and still work fine. This means that you can spawn particles from different locations and directions with the same emitter without the simulation going awry.</p></article></body></html><link rel="stylesheet" href="highlight-lisp.css"><script type="text/javascript" src="highlight-lisp.js"></script><script type="text/javascript">[...document.querySelectorAll('[data-language="common lisp"] pre')].map(HighlightLisp.highlight_element);</script>