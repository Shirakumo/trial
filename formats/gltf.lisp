#|
 This file is a part of trial
 (c) 2017 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(defpackage #:org.shirakumo.fraf.trial.gltf
  (:use #:cl+trial)
  (:shadow #:asset)
  (:local-nicknames
   (#:gltf #:org.shirakumo.fraf.gltf))
  (:export
   #:asset))
(in-package #:org.shirakumo.fraf.trial.gltf)

(defun gltf-node-transform (node)
  (let ((matrix (gltf:matrix node))
        (translation (gltf:translation node))
        (scale (gltf:scale node))
        (rotation (gltf:rotation node)))
    (let ((transform (if matrix
                         (tfrom-mat (mat4 matrix))
                         (transform))))
      (when translation
        (vsetf (tlocation transform)
               (aref translation 0)
               (aref translation 1)
               (aref translation 2)))
      (when scale
        (vsetf (tscaling transform)
               (aref scale 0)
               (aref scale 1)
               (aref scale 2)))
      (when rotation
        (qsetf (trotation transform)
               (aref rotation 0)
               (aref rotation 1)
               (aref rotation 2)
               (aref rotation 3)))
      transform)))

(defmethod gltf:construct-element-reader ((element-type (eql :scalar)) (component-type (eql :float)))
  (lambda (ptr)
    (values (cffi:mem-ref ptr :float)
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec2)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec3)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec4)) (component-type (eql :float)))
  (lambda (ptr)
    (values (quat (cffi:mem-ref ptr :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :mat4)) (component-type (eql :float)))
  (lambda (ptr)
    (let ((elements (make-array 16 :element-type 'single-float)))
      (dotimes (i (length elements))
        (setf (aref elements i) (cffi:mem-aref ptr :float i)))
      (values (nmtranspose (mat4 elements))
              (cffi:inc-pointer ptr (* 4 16))))))

(defun load-joint-names (gltf)
  (map 'vector #'gltf:name (gltf:nodes gltf)))

(defun load-rest-pose (gltf)
  (let* ((nodes (gltf:nodes gltf))
         (pose (make-instance 'pose :size (length nodes))))
    (loop for i from 0 below (length nodes)
          for node = (aref nodes i)
          do (setf (elt pose i) (gltf-node-transform node))
             (setf (parent-joint pose i) (if (gltf:parent node)
                                             (gltf:idx (gltf:parent node))
                                             -1)))
    (check-consistent pose)
    pose))

(defun load-animation-track (track sampler)
  (setf (interpolation track) (ecase (gltf:interpolation sampler)
                                (:step :constant)
                                (:linear :linear)
                                (:cubicspline :hermite)))
  (setf (frames track) (cons (gltf:input sampler) (gltf:output sampler))))

(defun load-clip (animation)
  (let ((clip (make-instance 'clip :name (gltf:name animation))))
    (loop for channel across (gltf:channels animation)
          for sampler = (svref (gltf:samplers animation) (gltf:sampler channel))
          for track = (find-animation-track clip (gltf:idx (gltf:node (gltf:target channel))) :if-does-not-exist :create)
          do (case (gltf:path (gltf:target channel))
               (:translation (load-animation-track (location track) sampler))
               (:scale (load-animation-track (scaling track) sampler))
               (:rotation (load-animation-track (rotation track) sampler))
               (T (warn "Unknown animation channel target path: ~s on ~s, ignoring."
                        (gltf:path (gltf:target channel)) (gltf:name animation)))))
    (trial::recompute-duration clip)))

(defun load-clips (gltf &optional (table (make-hash-table :test 'equal)))
  (loop for animation across (gltf:animations gltf)
        for clip = (load-clip animation)
        do (setf (gethash (name clip) table) clip))
  table)

(defun load-bind-pose (gltf)
  (let* ((rest-pose (load-rest-pose gltf))
         (world-bind-pose (make-array (length rest-pose))))
    (dotimes (i (length world-bind-pose))
      (setf (svref world-bind-pose i) (global-transform rest-pose i)))
    (loop for skin across (gltf:skins gltf)
          for joints = (gltf:joints skin)
          for acc = (gltf:inverse-bind-matrices skin)
          do (loop for i from 0 below (length joints)
                   for inv-bind-matrix = (elt acc i)
                   do (setf (aref world-bind-pose (gltf:idx (svref joints i)))
                            (tfrom-mat (minv inv-bind-matrix)))))
    (let ((bind-pose rest-pose))
      (loop for i from 0 below (length world-bind-pose)
            for current = (svref world-bind-pose i)
            for p = (parent-joint bind-pose i)
            do (setf (elt bind-pose i)
                     (if (<= 0 p)
                         (t+ (tinv (svref world-bind-pose p)) current)
                         current)))
      (check-consistent bind-pose)
      bind-pose)))

(defun load-skeleton (gltf)
  (make-instance 'skeleton :rest-pose (load-rest-pose gltf)
                           :bind-pose (load-bind-pose gltf)
                           :joint-names (load-joint-names gltf)))

(defun load-mesh-attribute (mesh attribute accessor skin)
  (let ((data (vertex-data mesh))
        (stride (etypecase mesh
                  ;; FIXME: this also sucks.
                  (trial:skinned-mesh (+ 3 3 2 4 4))
                  (trial:static-mesh (+ 3 3 2)))))
    (when (< (length data) (length accessor))
      (setf data (adjust-array data (* (length accessor) stride) :element-type 'single-float))
      (setf (vertex-data mesh) data))
    ;; FIXME: this sucks for a multitude of reasons as should be immediately clear lol
    (case attribute
      (:position
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 0)) (vx el))
                (setf (aref data (+ (* i stride) 1)) (vy el))
                (setf (aref data (+ (* i stride) 2)) (vz el))))
      (:normal
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 3)) (vx el))
                (setf (aref data (+ (* i stride) 4)) (vy el))
                (setf (aref data (+ (* i stride) 5)) (vz el))))
      (:tangent)
      (:texcoord_0
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 6)) (vx el))
                (setf (aref data (+ (* i stride) 7)) (vy el))))
      (:joints_0
       (flet ((map-joint (joint)
                (float (max 0 (gltf:idx (svref (gltf:joints skin) joint))) 0f0)))
         (loop for i from 0 below (length accessor)
               for el = (elt accessor i)
               do (setf (aref data (+ (* i stride) 8)) (map-joint (aref el 0)))
                  (setf (aref data (+ (* i stride) 9)) (map-joint (aref el 1)))
                  (setf (aref data (+ (* i stride) 10)) (map-joint (aref el 2)))
                  (setf (aref data (+ (* i stride) 11)) (map-joint (aref el 3))))))
      (:weights_0
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 12)) (qx el))
                (setf (aref data (+ (* i stride) 13)) (qy el))
                (setf (aref data (+ (* i stride) 14)) (qz el))
                (setf (aref data (+ (* i stride) 15)) (qw el))))
      (T
       (warn "Ignoring attribute ~s" attribute)))))

(defun load-meshes (gltf)
  (let ((meshes (make-array 0 :adjustable T :fill-pointer T)))
    (loop for node across (gltf:nodes gltf)
          for skin = (gltf:skin node)
          do (when (gltf:mesh node)
               (loop for primitive across (gltf:primitives (gltf:mesh node))
                     for name = (or (gltf:name (gltf:mesh node))
                                    (gltf:name node))
                     for mesh = (if (gltf:skin node)
                                    (make-instance 'skinned-mesh :name name)
                                    (make-instance 'static-mesh :name name))
                     do (vector-push-extend mesh meshes)
                        (when (gltf:material primitive)
                          (setf (material mesh) (or (gltf:name (gltf:material primitive))
                                                    (gltf:idx (gltf:material primitive)))))
                        (loop for attribute being the hash-keys of (gltf:attributes primitive)
                              for accessor being the hash-values of (gltf:attributes primitive)
                              do (load-mesh-attribute mesh attribute accessor skin))
                        (when (gltf:indices primitive)
                          (let* ((accessor (gltf:indices primitive))
                                 ;; KLUDGE: I don't know why the accessor is the wrong length here...
                                 (indexes (make-array (* 2 (length accessor)) :element-type '(unsigned-byte 32))))
                            (setf (index-data mesh) indexes)
                            (loop for i from 0 below (length indexes)
                                  do (setf (aref indexes i) (elt accessor i))))))))
    meshes))

(defclass asset (file-input-asset
                 multi-resource-asset
                 animation-asset
                 trial::full-load-asset)
  ())

(defun generate-image (asset texinfo)
  (when texinfo
    (let* ((texture (gltf:texture texinfo))
           (sampler (gltf:sampler texture))
           (image (gltf:source texture))
           (name (or (gltf:name image)
                     (gltf:uri image)
                     (gltf:name (gltf:buffer-view image))
                     (format NIL "image-~d" (gltf:idx image)))))
      (generate-resources 'image-loader (if (gltf:uri image)
                                            (gltf:path image)
                                            (memory-region (gltf:start (gltf:buffer-view image))
                                                           (gltf:byte-length (gltf:buffer-view image))))
                          :resource (resource asset name)
                          :mag-filter (gltf:mag-filter sampler)
                          :min-filter (gltf:min-filter sampler)
                          :wrapping (list (gltf:wrap-s sampler)
                                          (gltf:wrap-t sampler)
                                          :clamp-to-edge)
                          :mime-type (gltf:mime-type image)))))

(defmethod generate-resources ((asset asset) input &key)
  (gltf:with-gltf (gltf input)
    (let ((meshes (meshes asset))
          (clips (clips asset)))
      (flet ((to-vec (array)
               (ecase (length array)
                 (2 (vec (aref array 0) (aref array 1)))
                 (3 (vec (aref array 0) (aref array 1) (aref array 2)))
                 (4 (vec (aref array 0) (aref array 1) (aref array 2) (aref array 3))))))
        (loop for material across (gltf:materials gltf)
              for pbr = (gltf:pbr material)
              for name = (or (gltf:name material) (gltf:idx material))
              do (trial:update-material
                  name 'trial:pbr-material
                  :albedo-texture (generate-image asset (gltf:albedo pbr))
                  :metal-rough-texture (generate-image asset (gltf:metallic-roughness pbr))
                  :occlusion-texture (generate-image asset (gltf:metallic-roughness pbr))
                  :emissive-texture (generate-image asset (gltf:emissive-texture material))
                  :normal-texture (generate-image asset (gltf:normal-texture material))
                  :albedo-factor (to-vec (gltf:albedo-factor pbr))
                  :metallic-factor (float (gltf:metallic-factor pbr) 0f0)
                  :roughness-factor (float (gltf:roughness-factor pbr) 0f0)
                  :emissive-factor (to-vec (gltf:emissive-factor material))
                  :alpha-cutoff (float (gltf:alpha-cutoff material) 0f0))))
      (loop for mesh across (load-meshes gltf)
            for i from 0
            do (unless (name mesh)
                 (setf (name mesh) i))
               (setf (gethash (name mesh) meshes) mesh)
               (trial::make-vertex-array mesh (resource asset (name mesh))))
      (when (loop for mesh being the hash-values of meshes
                  thereis (skinned-p mesh))
        (setf (skeleton asset) (load-skeleton gltf))
        (load-clips gltf clips)
        (let ((map (make-hash-table :test 'eql)))
          (trial::reorder (skeleton asset) map)
          (loop for clip being the hash-values of (clips asset)
                do (trial::reorder clip map))
          (loop for mesh being the hash-values of (meshes asset)
                do (trial::reorder mesh map)))))))
