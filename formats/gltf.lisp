#|
 This file is a part of trial
 (c) 2017 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(defpackage #:org.shirakumo.fraf.trial.gltf
  (:use #:cl+trial)
  (:shadow #:asset)
  (:local-nicknames
   (#:gltf #:org.shirakumo.fraf.gltf)
   (#:v #:org.shirakumo.verbose))
  (:export
   #:asset))
(in-package #:org.shirakumo.fraf.trial.gltf)

(defun gltf-node-transform (node)
  (let ((matrix (gltf:matrix node))
        (translation (gltf:translation node))
        (scale (gltf:scale node))
        (rotation (gltf:rotation node)))
    (let ((transform (if matrix
                         (tfrom-mat (mat4 matrix))
                         (transform))))
      (when translation
        (vsetf (tlocation transform)
               (aref translation 0)
               (aref translation 1)
               (aref translation 2)))
      (when scale
        (vsetf (tscaling transform)
               (aref scale 0)
               (aref scale 1)
               (aref scale 2)))
      (when rotation
        (qsetf (trotation transform)
               (aref rotation 0)
               (aref rotation 1)
               (aref rotation 2)
               (aref rotation 3)))
      transform)))

(defmethod gltf:construct-element-reader ((element-type (eql :scalar)) (component-type (eql :float)))
  (lambda (ptr)
    (values (cffi:mem-ref ptr :float)
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec2)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec3)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec4)) (component-type (eql :float)))
  (lambda (ptr)
    (values (quat (cffi:mem-ref ptr :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :mat4)) (component-type (eql :float)))
  (lambda (ptr)
    (let ((elements (make-array 16 :element-type 'single-float)))
      (dotimes (i (length elements))
        (setf (aref elements i) (cffi:mem-aref ptr :float i)))
      (values (nmtranspose (mat4 elements))
              (cffi:inc-pointer ptr (* 4 16))))))

(defun load-joint-names (gltf)
  (map 'vector #'gltf:name (gltf:nodes gltf)))

(defun load-rest-pose (gltf)
  (let* ((nodes (gltf:nodes gltf))
         (pose (make-instance 'pose :size (length nodes))))
    (loop for i from 0 below (length nodes)
          for node = (aref nodes i)
          do (setf (elt pose i) (gltf-node-transform node))
             (setf (parent-joint pose i) (if (gltf:parent node)
                                             (gltf:idx (gltf:parent node))
                                             -1)))
    (check-consistent pose)
    pose))

(defun load-animation-track (track sampler)
  (setf (interpolation track) (ecase (gltf:interpolation sampler)
                                (:step :constant)
                                (:linear :linear)
                                (:cubicspline :hermite)))
  (setf (frames track) (cons (gltf:input sampler) (gltf:output sampler))))

(defun load-clip (animation)
  (let ((clip (make-instance 'clip :name (gltf:name animation))))
    (loop for channel across (gltf:channels animation)
          for sampler = (svref (gltf:samplers animation) (gltf:sampler channel))
          for track = (find-animation-track clip (gltf:idx (gltf:node (gltf:target channel))) :if-does-not-exist :create)
          do (case (gltf:path (gltf:target channel))
               (:translation (load-animation-track (location track) sampler))
               (:scale (load-animation-track (scaling track) sampler))
               (:rotation (load-animation-track (rotation track) sampler))
               (T (v:warn :trial.gltf "Unknown animation channel target path: ~s on ~s, ignoring."
                        (gltf:path (gltf:target channel)) (gltf:name animation)))))
    (trial::recompute-duration clip)))

(defun load-clips (gltf &optional (table (make-hash-table :test 'equal)))
  (loop for animation across (gltf:animations gltf)
        for clip = (load-clip animation)
        do (setf (gethash (name clip) table) clip))
  table)

(defun load-bind-pose (gltf)
  (let* ((rest-pose (load-rest-pose gltf))
         (world-bind-pose (make-array (length rest-pose))))
    (dotimes (i (length world-bind-pose))
      (setf (svref world-bind-pose i) (global-transform rest-pose i)))
    (loop for skin across (gltf:skins gltf)
          for joints = (gltf:joints skin)
          for acc = (gltf:inverse-bind-matrices skin)
          do (loop for i from 0 below (length joints)
                   for inv-bind-matrix = (elt acc i)
                   do (setf (aref world-bind-pose (gltf:idx (svref joints i)))
                            (tfrom-mat (minv inv-bind-matrix)))))
    (let ((bind-pose rest-pose))
      (loop for i from 0 below (length world-bind-pose)
            for current = (svref world-bind-pose i)
            for p = (parent-joint bind-pose i)
            do (setf (elt bind-pose i)
                     (if (<= 0 p)
                         (t+ (tinv (svref world-bind-pose p)) current)
                         current)))
      (check-consistent bind-pose)
      bind-pose)))

(defun load-skeleton (gltf)
  (make-instance 'skeleton :rest-pose (load-rest-pose gltf)
                           :bind-pose (load-bind-pose gltf)
                           :joint-names (load-joint-names gltf)))

(defun gltf-attribute-to-native-attribute (attribute)
  (case attribute
    (:position 'location)
    (:normal 'normal)
    (:tangent 'tangent)
    (:texcoord_0 'uv)
    (:texcoord_1 'uv-1)
    (:texcoord_2 'uv-2)
    (:texcoord_3 'uv-3)
    (:joints_0 'joints)
    (:joints_1 'joints-1)
    (:joints_2 'joints-2)
    (:joints_3 'joints-3)
    (:weights_0 'weights)
    (:weights_1 'weights-1)
    (:weights_2 'weights-2)
    (:weights_3 'weights-3)))

(defun load-vertex-attribute (mesh attribute accessor skin)
  (let ((data (vertex-data mesh))
        (stride (vertex-attribute-stride mesh))
        (offset (vertex-attribute-offset attribute mesh)))
    (when (< (length data) (length accessor))
      (setf data (adjust-array data (* (length accessor) stride) :element-type 'single-float))
      (setf (vertex-data mesh) data))
    (case (vertex-attribute-category attribute)
      (joints
       (flet ((map-joint (joint)
                (float (max 0 (gltf:idx (svref (gltf:joints skin) joint))) 0f0)))
         (loop for i from 0 below (length accessor)
               for el = (elt accessor i)
               do (setf (aref data (+ (* i stride) offset 0)) (map-joint (aref el 0)))
                  (setf (aref data (+ (* i stride) offset 1)) (map-joint (aref el 1)))
                  (setf (aref data (+ (* i stride) offset 2)) (map-joint (aref el 2)))
                  (setf (aref data (+ (* i stride) offset 3)) (map-joint (aref el 3))))))
      (uv
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) offset 0)) (vx2 el))
                (setf (aref data (+ (* i stride) offset 1)) (- 1.0 (vy2 el)))))
      (T
       (ecase (vertex-attribute-size attribute)
         (1
          (loop for i from 0 below (length accessor)
                for el = (elt accessor i)
                do (setf (aref data (+ (* i stride) offset)) (float el 0f0))))
         (2
          (loop for i from 0 below (length accessor)
                for el = (elt accessor i)
                do (setf (aref data (+ (* i stride) offset 0)) (vx2 el))
                   (setf (aref data (+ (* i stride) offset 1)) (vy2 el))))
         (3
          (loop for i from 0 below (length accessor)
                for el = (elt accessor i)
                do (setf (aref data (+ (* i stride) offset 0)) (vx3 el))
                   (setf (aref data (+ (* i stride) offset 1)) (vy3 el))
                   (setf (aref data (+ (* i stride) offset 2)) (vz3 el))))
         (4
          (loop for i from 0 below (length accessor)
                for el = (elt accessor i)
                do (setf (aref data (+ (* i stride) offset 0)) (qx el))
                   (setf (aref data (+ (* i stride) offset 1)) (qy el))
                   (setf (aref data (+ (* i stride) offset 2)) (qz el))
                   (setf (aref data (+ (* i stride) offset 3)) (qw el)))))))))

(defun load-meshes (gltf)
  (let ((meshes (make-array 0 :adjustable T :fill-pointer T)))
    (loop for node across (gltf:nodes gltf)
          for skin = (gltf:skin node)
          do (when (gltf:mesh node)
               (loop for primitive across (gltf:primitives (gltf:mesh node))
                     for name = (or (gltf:name (gltf:mesh node))
                                    (gltf:name node))
                     for attributes = (sort (loop for attribute being the hash-keys of (gltf:attributes primitive)
                                                  for native = (gltf-attribute-to-native-attribute attribute)
                                                  when native collect native)
                                            #'vertex-attribute<)
                     for mesh = (make-instance (if (gltf:skin node) 'skinned-mesh 'static-mesh)
                                               :name name :vertex-form (gltf:mode primitive)
                                               :vertex-attributes attributes)
                     do (vector-push-extend mesh meshes)
                        (when (gltf:material primitive)
                          (setf (material mesh) (or (gltf:name (gltf:material primitive))
                                                    (gltf:idx (gltf:material primitive)))))
                        (loop for attribute being the hash-keys of (gltf:attributes primitive) using (hash-value accessor)
                              for native = (gltf-attribute-to-native-attribute attribute)
                              do (when (member native attributes)
                                   (load-vertex-attribute mesh native accessor skin)))
                        (when (gltf:indices primitive)
                          (let* ((accessor (gltf:indices primitive))
                                 (indexes (make-array (length accessor) :element-type '(unsigned-byte 32))))
                            (setf (index-data mesh) indexes)
                            (loop for i from 0 below (length indexes)
                                  do (setf (aref indexes i) (elt accessor i))))))))
    meshes))

(defclass asset (file-input-asset
                 multi-resource-asset
                 animation-asset
                 trial::full-load-asset)
  ())

(defun generate-image (asset texinfo)
  (when texinfo
    (let* ((texture (gltf:texture texinfo))
           (sampler (gltf:sampler texture))
           (image (gltf:source texture))
           (name (or (gltf:name image)
                     (gltf:uri image)
                     (gltf:name (gltf:buffer-view image))
                     (format NIL "image-~d" (gltf:idx image)))))
      (generate-resources 'image-loader (if (gltf:uri image)
                                            (gltf:path image)
                                            (memory-region (gltf:start (gltf:buffer-view image))
                                                           (gltf:byte-length (gltf:buffer-view image))))
                          :type (gltf:mime-type image)
                          :resource (resource asset name)
                          :mag-filter (gltf:mag-filter sampler)
                          :min-filter (gltf:min-filter sampler)
                          :wrapping (list (gltf:wrap-s sampler)
                                          (gltf:wrap-t sampler)
                                          :clamp-to-edge)))))

(defmethod generate-resources ((asset asset) input &key)
  (gltf:with-gltf (gltf input)
    (let ((meshes (meshes asset))
          (clips (clips asset)))
      (flet ((to-vec (array)
               (ecase (length array)
                 (2 (vec (aref array 0) (aref array 1)))
                 (3 (vec (aref array 0) (aref array 1) (aref array 2)))
                 (4 (vec (aref array 0) (aref array 1) (aref array 2) (aref array 3))))))
        (loop for material across (gltf:materials gltf)
              for pbr = (gltf:pbr material)
              for name = (or (gltf:name material) (gltf:idx material))
              do (trial:update-material
                  name 'trial:pbr-material
                  :albedo-texture (generate-image asset (gltf:albedo pbr))
                  :metal-rough-texture (generate-image asset (gltf:metallic-roughness pbr))
                  :occlusion-texture (generate-image asset (gltf:occlusion-texture material))
                  :emissive-texture (generate-image asset (gltf:emissive-texture material))
                  :normal-texture (generate-image asset (gltf:normal-texture material))
                  :albedo-factor (to-vec (gltf:albedo-factor pbr))
                  :metallic-factor (float (gltf:metallic-factor pbr) 0f0)
                  :roughness-factor (float (gltf:roughness-factor pbr) 0f0)
                  :emissive-factor (to-vec (gltf:emissive-factor material))
                  :occlusion-factor (if (gltf:occlusion-texture material) 1.0 0.0)
                  :alpha-cutoff (float (gltf:alpha-cutoff material) 0f0))))
      (loop for mesh across (load-meshes gltf)
            for i from 0
            do (unless (name mesh)
                 (setf (name mesh) i))
               (setf (gethash (name mesh) meshes) mesh)
               (trial::make-vertex-array mesh (resource asset (name mesh))))
      (when (loop for mesh being the hash-values of meshes
                  thereis (skinned-p mesh))
        (setf (skeleton asset) (load-skeleton gltf))
        (load-clips gltf clips)
        (let ((map (make-hash-table :test 'eql)))
          (trial::reorder (skeleton asset) map)
          (loop for clip being the hash-values of (clips asset)
                do (trial::reorder clip map))
          (loop for mesh being the hash-values of (meshes asset)
                do (trial::reorder mesh map)))))))
