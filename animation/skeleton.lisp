#|
 This file is a part of trial
 (c) 2022 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.fraf.trial)

(defclass skeleton ()
  ((rest-pose :initarg :rest-pose :accessor rest-pose)
   (bind-pose :initarg :bind-pose :accessor bind-pose)
   (inv-bind-pose :accessor inv-bind-pose)
   (joint-names :initarg :joint-names :accessor joint-names)))

(defmethod shared-initialize :after ((skeleton skeleton) slots &key)
  (update-bind-pose skeleton))

(defmethod (setf bind-pose) :after (pose (skeleton skeleton))
  (update-bind-pose skeleton))

(defun update-bind-pose (skeleton)
  (let* ((pose (bind-pose skeleton))
         (inv (make-array (length pose))))
    (dotimes (i (length inv) (setf (inv-bind-pose skeleton) inv))
      (let ((transform (global-transform pose i)))
        (setf (svref inv i) (minv (tmat4 transform)))))))

(defmethod reorder ((skeleton skeleton) map)
  (let* ((rest (rest-pose skeleton))
         (bind (bind-pose skeleton))
         (forward (make-hash-table :test 'eql))
         (backward map)
         (hierarchy (make-array (length rest)))
         (process (make-array 0 :adjustable T :fill-pointer T)))
    (clrhash backward)
    (map-into hierarchy (lambda () (make-array 0 :element-type '(unsigned-byte 16) :adjustable T :fill-pointer T)))
    (dotimes (i (length rest))
      (let ((parent (parent-joint rest i)))
        (if (<= 0 parent)
            (vector-push-extend i (svref hierarchy parent))
            (vector-push-extend i process))))
    (loop for i from 0
          while (< i (length process))
          do (let* ((current (aref process i)))
               (loop for child across (svref hierarchy current)
                     do (vector-push-extend child process))
               (setf (gethash i forward) current)
               (setf (gethash current backward) i)))
    (setf (gethash -1 forward) -1)
    (setf (gethash -1 backward) -1)
    (let ((new-rest (make-instance 'pose :size (length rest)))
          (new-bind (make-instance 'pose :size (length rest)))
          (new-names (make-array (length rest))))
      (dotimes (i (length rest))
        (let* ((this (gethash i forward))
               (parent (gethash (parent-joint bind this) backward)))
          (setf (elt new-rest i) (elt rest this))
          (setf (elt new-bind i) (elt bind this))
          (setf (svref new-names i) (aref (joint-names skeleton) i))
          (setf (parent-joint new-rest i) parent)
          (setf (parent-joint new-bind i) parent)))
      (check-consistent new-rest)
      (check-consistent new-bind)
      (setf (rest-pose skeleton) new-rest)
      (setf (bind-pose skeleton) new-bind)
      skeleton)))

(defun instantiate-clip (skeleton clip &optional (time (start-time clip)))
  (let ((pose (rest-pose* skeleton)))
    (sample pose clip time)
    pose))

(defmethod rest-pose* ((skeleton skeleton))
  (make-instance 'pose :source (rest-pose skeleton)))
