#|
 This file is a part of trial
 (c) 2022 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.fraf.trial)

(defun describe-skeleton (skeleton stream)
  (let ((parents (parents (rest-pose skeleton)))
        (names (joint-names skeleton)))
    (labels ((recurse (i last)
               (when last
                 (destructuring-bind (cur . rest) last
                   (dolist (p (reverse rest))
                     (format stream "~:[│  ~;   ~]" p))
                   (format stream "~:[├~;└~]─" cur)))
               (format stream " ~2d ~@[~s~]~%" i (when (<= 0 i) (aref names i)))
               (loop with max = (loop for j from 0 below (length parents)
                                      when (= (aref parents j) i) maximize j)
                     for j from 0 below (length parents)
                     do (when (= (aref parents j) i)
                          (recurse j (list* (= max j) last))))))
      (recurse -1 ()))))

(defclass skeleton ()
  ((rest-pose :initarg :rest-pose :accessor rest-pose)
   (bind-pose :initarg :bind-pose :accessor bind-pose)
   (inv-bind-pose :accessor inv-bind-pose)
   (joint-names :initarg :joint-names :accessor joint-names)))

(defmethod describe-object ((skeleton skeleton) stream)
  (call-next-method)
  (terpri)
  (describe-skeleton skeleton stream))

(defmethod shared-initialize :after ((skeleton skeleton) slots &key)
  (update-bind-pose skeleton))

(defmethod (setf bind-pose) :after (pose (skeleton skeleton))
  (update-bind-pose skeleton))

(defun update-bind-pose (skeleton)
  (let* ((pose (bind-pose skeleton))
         (inv (make-array (length pose))))
    (dotimes (i (length inv) (setf (inv-bind-pose skeleton) inv))
      (let ((transform (global-transform pose i)))
        (setf (svref inv i) (minv (tmat4 transform)))))))

(defmethod reorder ((skeleton skeleton) map)
  (let* ((rest (rest-pose skeleton))
         (bind (bind-pose skeleton))
         (names (joint-names skeleton))
         (forward (make-hash-table :test 'eql))
         (backward map)
         (hierarchy (make-array (length rest)))
         (process (make-array 0 :adjustable T :fill-pointer T)))
    (clrhash backward)
    (map-into hierarchy (lambda () (make-array 0 :element-type '(unsigned-byte 16) :adjustable T :fill-pointer T)))
    (dotimes (i (length rest))
      (let ((parent (parent-joint rest i)))
        (if (<= 0 parent)
            (vector-push-extend i (svref hierarchy parent))
            (vector-push-extend i process))))
    (loop for i from 0
          while (< i (length process))
          do (let* ((current (aref process i)))
               (loop for child across (svref hierarchy current)
                     do (vector-push-extend child process))
               (setf (gethash i forward) current)
               (setf (gethash current backward) i)))
    (setf (gethash -1 forward) -1)
    (setf (gethash -1 backward) -1)
    (let ((new-rest (make-instance 'pose :size (length rest)))
          (new-bind (make-instance 'pose :size (length rest)))
          (new-names (make-array (length rest))))
      (dotimes (i (length rest))
        (let* ((this (gethash i forward))
               (parent (gethash (parent-joint bind this) backward)))
          (setf (elt new-rest i) (elt rest this))
          (setf (elt new-bind i) (elt bind this))
          (setf (svref new-names i) (aref names this))
          (setf (parent-joint new-rest i) parent)
          (setf (parent-joint new-bind i) parent)))
      (check-consistent new-rest)
      (check-consistent new-bind)
      (setf (rest-pose skeleton) new-rest)
      (setf (bind-pose skeleton) new-bind)
      (setf (joint-names skeleton) new-names)
      skeleton)))

(defun instantiate-clip (skeleton clip &key (time (start-time clip)) (pose (rest-pose* skeleton)))
  (sample pose clip time)
  pose)

(defmethod rest-pose* ((skeleton skeleton))
  (make-instance 'pose :source (rest-pose skeleton)))
