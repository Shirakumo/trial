#|
 This file is a part of trial
 (c) 2022 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.fraf.trial.animation)

(defun node-transform (node)
  (let ((matrix (gltf:matrix node))
        (translation (gltf:translation node))
        (scale (gltf:scale node))
        (rotation (gltf:rotation node)))
    (let ((transform (if matrix
                         (tfrom-mat (mat4 matrix))
                         (transform))))
      (when translation
        (vsetf (tlocation transform)
               (aref translation 0)
               (aref translation 1)
               (aref translation 2)))
      (when scale
        (vsetf (tscaling transform)
               (aref scale 0)
               (aref scale 1)
               (aref scale 2)))
      (when rotation
        (qsetf (trotation transform)
               (aref rotation 0)
               (aref rotation 1)
               (aref rotation 2)
               (aref rotation 3)))
      transform)))

(defmethod gltf:construct-element-reader ((element-type (eql :scalar)) (component-type (eql :float)))
  (lambda (ptr)
    (values (cffi:mem-ref ptr :float)
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec2)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec3)) (component-type (eql :float)))
  (lambda (ptr)
    (values (vec (cffi:mem-ref ptr :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                 (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :vec4)) (component-type (eql :float)))
  (lambda (ptr)
    (values (quat (cffi:mem-ref ptr :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float)
                  (cffi:mem-ref (cffi:incf-pointer ptr 4) :float))
            (cffi:incf-pointer ptr 4))))

(defmethod gltf:construct-element-reader ((element-type (eql :mat4)) (component-type (eql :float)))
  (lambda (ptr)
    (let ((elements (make-array 16 :element-type 'single-float)))
      (dotimes (i (length elements))
        (setf (aref elements i) (cffi:mem-aref ptr :float i)))
      (values (nmtranspose (mat4 elements))
              (cffi:inc-pointer ptr (* 4 16))))))

(defun load-joint-names (gltf)
  (map 'vector #'gltf:name (gltf:nodes gltf)))

(defun load-rest-pose (gltf)
  (let* ((nodes (gltf:nodes gltf))
         (pose (make-instance 'pose :size (length nodes))))
    (loop for i from 0 below (length nodes)
          for node = (aref nodes i)
          do (setf (elt pose i) (node-transform node))
             (setf (parent-joint pose i) (if (gltf:parent node)
                                             (gltf:idx (gltf:parent node))
                                             -1)))
    pose))

(defun access (json accessor)
  (let ((view (g json "bufferViews" (g accessor "bufferView")))
        (buff (g json "buffers" (g view "buffer"))))))

(defun load-track (track sampler)
  (setf (interpolation track) (ecase (gltf:interpolation sampler)
                                (:step :constant)
                                (:linear :linear)
                                (:cubicspline :hermite)))
  (setf (frames track) (cons (gltf:input sampler) (gltf:output sampler))))

(defun load-clip (animation)
  (let ((clip (make-instance 'clip :name (gltf:name animation))))
    (loop for channel across (gltf:channels animation)
          for sampler = (svref (gltf:samplers animation) (gltf:sampler channel))
          for track = (find-track clip (gltf:idx (gltf:node (gltf:target channel))) :if-does-not-exist :create)
          do (ecase (gltf:path (gltf:target channel))
               (:translation (load-track (location track) sampler))
               (:scale (load-track (scaling track) sampler))
               (:rotation (load-track (rotation track) sampler))))
    (recompute-duration clip)))

(defun load-clips (gltf)
  (let ((table (make-hash-table :test 'equal)))
    (loop for animation across (gltf:animations gltf)
          for clip = (load-clip animation)
          do (setf (gethash (trial:name clip) table) clip))
    table))

(defun load-bind-pose (gltf)
  (let* ((rest-pose (load-rest-pose gltf))
         (world-bind-pose (make-array (length rest-pose))))
    (dotimes (i (length world-bind-pose))
      (setf (svref world-bind-pose i) (global-transform rest-pose i)))
    (loop for skin across (gltf:skins gltf)
          for joints = (gltf:joints skin)
          for acc = (gltf:inverse-bind-matrices skin)
          do (loop for i from 0 below (length joints)
                   for inv-bind-matrix = (elt acc i)
                   do (setf (aref world-bind-pose (gltf:idx (svref joints i)))
                            (tfrom-mat (minv inv-bind-matrix)))))
    (let ((bind-pose rest-pose))
      (loop for i from 0 below (length world-bind-pose)
            for current = (svref world-bind-pose i)
            for p = (parent-joint bind-pose i)
            do (setf (elt bind-pose i)
                     (if (<= 0 p)
                         (t+ (tinv (svref world-bind-pose p)) current)
                         current)))
      bind-pose)))

(defun load-skeleton (gltf)
  (make-instance 'skeleton :rest-pose (load-rest-pose gltf)
                           :bind-pose (load-bind-pose gltf)
                           :joint-names (load-joint-names gltf)))

(defun load-mesh-attribute (mesh attribute accessor skin)
  (let ((data (vertex-data mesh))
        (stride (+ 3 3 2 4 4)))
    (when (< (length data) (length accessor))
      (setf data (adjust-array data (* (length accessor) stride) :element-type 'single-float))
      (setf (vertex-data mesh) data))
    ;; FIXME: this sucks for a multitude of reasons as should be immediately clear lol
    (ecase attribute
      (:position
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 0)) (vx el))
                (setf (aref data (+ (* i stride) 1)) (vy el))
                (setf (aref data (+ (* i stride) 2)) (vz el))))
      (:normal
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 3)) (vx el))
                (setf (aref data (+ (* i stride) 4)) (vy el))
                (setf (aref data (+ (* i stride) 5)) (vz el))))
      (:texcoord_0
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 6)) (vx el))
                (setf (aref data (+ (* i stride) 7)) (vy el))))
      (:joints_0
       (flet ((map-joint (joint)
                (float (max 0 (gltf:idx (svref (gltf:joints skin) joint))) 0f0)))
         (loop for i from 0 below (length accessor)
               for el = (elt accessor i)
               do (setf (aref data (+ (* i stride) 8)) (map-joint (aref el 0)))
                  (setf (aref data (+ (* i stride) 9)) (map-joint (aref el 1)))
                  (setf (aref data (+ (* i stride) 10)) (map-joint (aref el 2)))
                  (setf (aref data (+ (* i stride) 11)) (map-joint (aref el 3))))))
      (:weights_0
       (loop for i from 0 below (length accessor)
             for el = (elt accessor i)
             do (setf (aref data (+ (* i stride) 12)) (qx el))
                (setf (aref data (+ (* i stride) 13)) (qy el))
                (setf (aref data (+ (* i stride) 14)) (qz el))
                (setf (aref data (+ (* i stride) 15)) (qw el)))))))

(defun load-meshes (gltf)
  (let ((meshes (make-array 0 :adjustable T :fill-pointer T)))
    (loop for node across (gltf:nodes gltf)
          for skin = (gltf:skin node)
          do (when (gltf:mesh node)
               (loop for primitive across (gltf:primitives (gltf:mesh node))
                     for mesh = (make-instance 'mesh :name (or (gltf:name (gltf:mesh node))
                                                               (gltf:name node))
                                                     :skinned-p (not (null (gltf:skin node))))
                     do (vector-push-extend mesh meshes)
                        (setf (trial:texture mesh) (gltf:material primitive))
                        (loop for attribute being the hash-keys of (gltf:attributes primitive)
                              for accessor being the hash-values of (gltf:attributes primitive)
                              do (load-mesh-attribute mesh attribute accessor skin))
                        (when (gltf:indices primitive)
                          (let* ((accessor (gltf:indices primitive))
                                 ;; KLUDGE: I don't know why the accessor is the wrong length here...
                                 (indexes (make-array (* 2 (length accessor)) :element-type '(unsigned-byte 32))))
                            (setf (index-data mesh) indexes)
                            (loop for i from 0 below (length indexes)
                                  do (setf (aref indexes i) (elt accessor i))))))))
    meshes))
