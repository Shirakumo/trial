(in-package #:org.shirakumo.fraf.trial)

(defstruct (contact (:include hit))
  (to-world (mat3) :type mat3)
  (velocity (vec3 0 0 0) :type vec3)
  (desired-delta 0.0 :type single-float)
  (a-relative (vec3 0 0 0) :type vec3)
  (b-relative (vec3 0 0 0) :type vec3)
  (a-rotation-change (vec3 0 0 0) :type vec3)
  (b-rotation-change (vec3 0 0 0) :type vec3)
  (a-velocity-change (vec3 0 0 0) :type vec3)
  (b-velocity-change (vec3 0 0 0) :type vec3))

(defun hit-basis (hit &optional (basis (mat3)))
  (let ((normal (hit-normal hit))
        (tangent-0 (vec3 0 0 0))
        (tangent-1 (vec3 0 0 0)))
    (declare (dynamic-extent tangent-0 tangent-1))
    (cond ((< (abs (vy normal)) (abs (vx normal)))
           (let ((s (/ (sqrt (+ (* (vz normal) (vz normal))
                                (* (vx normal) (vx normal)))))))
             (vsetf tangent-0 (* (vz normal) s) 0.0 (- (* (vx normal) s)))
             (vsetf tangent-1
                    (* (vy normal) (vx tangent-0))
                    (- (* (vz normal) (vx tangent-0))
                       (* (vx normal) (vz tangent-0)))
                    (- (* (vy normal) (vx tangent-0))))))
          (T
           (let ((s (/ (sqrt (+ (* (vz normal) (vz normal))
                                (* (vy normal) (vy normal)))))))
             (vsetf tangent-0 0.0 (- (* (vz normal) s)) (* (vy normal) s))
             (vsetf tangent-1
                    (- (* (vy normal) (vz tangent-0))
                       (* (vz normal) (vy tangent-0)))
                    (- (* (vx normal) (vz tangent-0)))
                    (* (vx normal) (vy tangent-0))))))
    (with-fast-matref (m basis 3)
      (setf (m 0) (vx normal))
      (setf (m 1) (vx tangent-0))
      (setf (m 2) (vx tangent-1))
      (setf (m 3) (vy normal))
      (setf (m 4) (vy tangent-0))
      (setf (m 5) (vy tangent-1))
      (setf (m 6) (vz normal))
      (setf (m 7) (vz tangent-0))
      (setf (m 8) (vz tangent-1))
      basis)))

(defun local-velocity (to-world entity loc dt)
  (let ((vel (ntransform-inverse
              (nv+ (vc (rotation entity) loc)
                   (velocity entity))
              to-world))
        (acc (ntransform-inverse
              (v* (force entity) (inverse-mass entity) dt)
              to-world)))
    (setf (vx acc) 0.0)
    (nv+ vel acc)))

(defun desired-delta-velocity (hit velocity dt)
  (let ((limit 0.25))
    (flet ((acc (entity)
             (v. (v* (force entity) (inverse-mass entity) dt)
                 (hit-normal hit))))
      (let ((vx (vx velocity)))
        (- 0.0 vx (if (< (abs vx) limit)
                      0.0
                      (* (hit-restitution hit)
                         (- vx
                            (acc (hit-a hit))
                            (acc (hit-b hit))))))))))

(defun upgrade-hit-to-contact (hit dt)
  (let* ((to-world (hit-basis hit))
         (a-relative (v- (hit-location hit) (location (hit-a hit))))
         (b-relative (v- (hit-location hit) (location (hit-b hit))))
         (velocity (nv- (local-velocity to-world (hit-a hit) a-relative dt)
                        (local-velocity to-world (hit-b hit) b-relative dt)))
         (desired-delta (desired-delta-velocity hit velocity dt)))
    (setf (contact-to-world hit) to-world)
    (setf (contact-velocity hit) velocity)
    (setf (contact-desired-delta hit) desired-delta)
    (setf (contact-a-relative hit) a-relative)
    (setf (contact-b-relative hit) b-relative)
    hit))

(defun frictionless-impulse (contact &optional (impulse (vec3 0 0 0)))
  (flet ((body-delta-vel (loc body)
           (let ((delta-vel (vc loc (contact-normal contact))))
             (n*m (world-inverse-inertia-tensor body) delta-vel)
             (setf delta-vel (vc delta-vel loc))
             (+ (inverse-mass body) (v. delta-vel (contact-normal contact))))))
    (vsetf impulse
           (/ (contact-desired-delta contact)
              (+ (body-delta-vel (contact-a-relative contact) (contact-a contact))
                 (body-delta-vel (contact-b-relative contact) (contact-b contact))))
           0.0
           0.0)))

(defun apply-velocity-change (contact)
  (let ((impulse (vec 0 0 0)))
    (declare (dynamic-extent impulse))
    (if (= 0 (contact-friction contact))
        (frictionless-impulse contact impulse)
        (error "Dew it."))
    (n*m (contact-to-world contact) impulse)
    (let ((entity (contact-a contact))
          (velocity-change (contact-a-velocity-change contact))
          (rotation-change (contact-a-rotation-change contact)))
      (v<- rotation-change (vc (contact-a-relative contact) impulse))
      (n*m (world-inverse-inertia-tensor entity) rotation-change)
      (vsetf velocity-change 0 0 0)
      (nv+* velocity-change impulse (inverse-mass entity))
      (nv+ (rotation entity) rotation-change)
      (nv+ (velocity entity) velocity-change))
    ;; Second body needs to invert the direction.
    (let ((entity (contact-b contact))
          (velocity-change (contact-b-velocity-change contact))
          (rotation-change (contact-b-rotation-change contact)))
      (v<- rotation-change (vc impulse (contact-b-relative contact)))
      (n*m (inverse-inertia-tensor entity) rotation-change)
      (vsetf velocity-change 0 0 0)
      (nv+* velocity-change impulse (- (inverse-mass entity)))
      (nv+ (rotation entity) rotation-change)
      (nv+ (velocity entity) velocity-change))))

(defun apply-position-change (contact)
  (flet ((angular-inertia (entity loc)
           (v. (vc (n*m (inverse-inertia-tensor entity)
                        (vc loc (contact-normal contact)))
                   loc)
               (contact-normal contact)))
         (linear-inertia (entity)
           (inverse-mass entity))
         (change (entity loc angular-inertia linear-inertia total-inertia
                         rotation-change velocity-change)
           (let ((angular-move (* (contact-depth contact)
                                  (/ angular-inertia total-inertia)))
                 (linear-move (* (contact-depth contact)
                                 (/ linear-inertia total-inertia)))
                 (projection (v* (contact-normal contact)
                                 (- (v. loc (contact-normal contact))))))
             (nv+ projection loc)
             (let ((max (* 0.2 (vlength projection)))
                   (total (+ angular-move linear-move)))
               (cond ((< angular-move (- max))
                      (setf angular-move (- max))
                      (setf linear-move (- total angular-move)))
                     ((< max angular-move)
                      (setf angular-move max)
                      (setf linear-move (- total angular-move))))
               (vsetf rotation-change 0 0 0)
               (v<- velocity-change (contact-normal contact))
               (when (/= 0 angular-move)
                 (v<- rotation-change (vc loc (contact-normal contact)))
                 (n*m (inverse-inertia-tensor entity) rotation-change)
                 (nv* rotation-change (/ angular-move angular-inertia)))
               (nv* velocity-change linear-move)
               (nv+ (location entity) velocity-change)
               (nq+* (orientation entity) rotation-change 1.0)))))
    (let* ((a (contact-a contact))
           (b (contact-b contact))
           (a-angular-inertia (angular-inertia a (contact-a-relative contact)))
           (b-angular-inertia (angular-inertia b (contact-b-relative contact)))
           (a-linear-inertia (linear-inertia a))
           (b-linear-inertia (linear-inertia b))
           (total-inertia (+ a-angular-inertia b-angular-inertia
                             a-linear-inertia b-linear-inertia)))
      (change a (contact-a-relative contact) a-angular-inertia a-linear-inertia total-inertia
              (contact-a-rotation-change contact) (contact-a-velocity-change contact))
      (change b (contact-b-relative contact) b-angular-inertia b-linear-inertia (- total-inertia)
              (contact-b-rotation-change contact) (contact-b-velocity-change contact)))))

(defun resolve-contacts (contacts end dt &key (iterations 20))
  (macrolet ((do-contacts ((contact) &body body)
               `(loop for i from 0 below end
                      for ,contact = (aref contacts i)
                      do (progn ,@body)))
             (do-update (args &body body)
               `(do-contacts (other)
                  (flet ((change ,args
                           ,@body))
                    (cond ((eq (contact-a other) (contact-a contact))
                           (change (contact-a-rotation-change contact)
                                   (contact-a-velocity-change contact)
                                   (contact-a-relative other) -1))
                          ((eq (contact-a other) (contact-b contact))
                           (change (contact-b-rotation-change contact)
                                   (contact-b-velocity-change contact)
                                   (contact-a-relative other) -1))
                          ((eq (contact-b other) (contact-a contact))
                           (change (contact-a-rotation-change contact)
                                   (contact-a-velocity-change contact)
                                   (contact-b-relative other) +1))
                          ((eq (contact-b other) (contact-b contact))
                           (change (contact-b-rotation-change contact)
                                   (contact-b-velocity-change contact)
                                   (contact-b-relative other) +1)))))))
    (do-contacts (contact)
      (upgrade-hit-to-contact contact dt))
    (loop repeat iterations
          for worst = 0.0
          for contact = NIL
          do (do-contacts (tentative)
               (when (< worst (contact-depth tentative))
                 (setf contact tentative)
                 (setf worst (contact-depth contact))))
             (unless contact (loop-finish))
             (apply-position-change contact)
             ;; We now need to fix up the contact depths.
             (do-update (rotation-change velocity-change loc sign)
               (incf (contact-depth other)
                     (* sign (v. (nv+ (vc rotation-change loc) velocity-change)
                                 (contact-normal other))))))
    (loop repeat iterations
          for worst = 0.01 ;; Some kinda epsilon.
          for contact = NIL
          do (do-contacts (tentative)
               (when (< worst (contact-desired-delta tentative))
                 (setf contact tentative)
                 (setf worst (contact-desired-delta contact))))
             (unless contact (loop-finish))
             (apply-velocity-change contact)
             (do-update (rotation-change velocity-change loc sign)
               (let ((delta (nv+ (vc rotation-change loc) velocity-change)))
                 (nv+* (contact-velocity other) (n*m (contact-to-world other) delta) sign)
                 (setf (contact-desired-delta other)
                       (desired-delta-velocity other (contact-velocity other) dt)))))))

(defclass rigidbody-system (physics-system entity listener)
  ((contact-data :initform (make-contact-data) :accessor contact-data)))

(define-handler (rigidbody-system tick) (dt)
  (start-frame rigidbody-system)
  (let ((forces (forces rigidbody-system))
        (objects (%objects rigidbody-system)))
    (loop for entity across objects
          do (loop for force across forces
                   do (apply-force force entity dt)))
    (let ((data (contact-data rigidbody-system)))
      (setf (contact-data-start data) 0)
      ;; Compute contacts
      ;; TODO: replace with something that isn't as dumb as this.
      (loop for i from 0 below (length objects)
            for a = (aref objects i)
            do (loop for j from (1+ i) below (length objects)
                     for b = (aref objects j)
                     do (loop for a-p across (physics-primitives a)
                              do (loop for b-p across (physics-primitives b)
                                       do ;; (setf (contact-data-friction data) (static-friction (primitive-material a-p) (primitive-material b-p)))
                                       (setf (contact-data-restitution data) 0.2) ; ??? Hard-coded ???
                                       (detect-hits a-p b-p data)))))
      ;; Resolve contacts
      (when (< 0 (contact-data-start data))
        (resolve-contacts (contact-data-hits data) (contact-data-start data) dt)
        (loop for i from 0 below (contact-data-start data)
              for contact = (aref (contact-data-hits data) i)
              do (debug-line (contact-location contact)
                             (v+ (contact-location contact)
                                 (v* (contact-normal contact) 10)))
                 (debug-draw (contact-a contact))))))
  (integrate rigidbody-system dt))
