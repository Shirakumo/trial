(in-package #:org.shirakumo.fraf.trial)

(defstruct (contact (:include hit))
  (to-world (mat3) :type mat3)
  (velocity (vec3 0 0 0) :type vec3)
  (desired-delta 0.0 :type single-float)
  (a-relative (vec3 0 0 0) :type vec3)
  (b-relative (vec3 0 0 0) :type vec3))

(defun hit-basis (hit &optional (basis (mat3)))
  (let ((normal (hit-normal hit))
        (tangent-0 (vec3 0 0 0))
        (tangent-1 (vec3 0 0 0)))
    (declare (dynamic-extent tangent-0 tangent-1))
    (cond ((< (abs (vy normal)) (abs (vx normal)))
           (let ((s (/ (sqrt (+ (* (vz normal) (vz normal))
                                (* (vx normal) (vx normal)))))))
             (vsetf tangent-0 (* (vz normal) s) 0.0 (* (vx normal) s -1))
             (vsetf tangent-1
                    (* (vy normal) (vx tangent-0))
                    (- (* (vz normal) (vx tangent-0))
                       (* (vx normal) (vz tangent-0)))
                    (* (vy normal) (vx tangent-0) -1))))
          (T
           (let ((s (/ (sqrt (+ (* (vz normal) (vz normal))
                                (* (vy normal) (vy normal)))))))
             (vsetf tangent-0 0.0 (* (vz normal) s -1) (* (vy normal) s))
             (vsetf tangent-1
                    (- (* (vy normal) (vz tangent-0))
                       (* (vz normal) (vy tangent-0)))
                    (* (vx normal) (vz tangent-0) -1)
                    (* (vx normal) (vy tangent-0))))))
    (with-fast-matref (m basis 3)
      (setf (m 0 0) (vx normal))
      (setf (m 1 0) (vy normal))
      (setf (m 2 0) (vz normal))
      (setf (m 0 1) (vx tangent-0))
      (setf (m 1 1) (vy tangent-0))
      (setf (m 2 1) (vz tangent-0))
      (setf (m 0 2) (vx tangent-1))
      (setf (m 1 2) (vy tangent-1))
      (setf (m 2 2) (vz tangent-1)))))

(defun local-velocity (to-world loc entity dt)
  (let ((vel (ntransform-inverse
              (nv+ (vc (rotation entity) loc)
                   (velocity entity))
              to-world))
        (acc (ntransform-inverse
              (v* (force entity) (inverse-mass entity) dt)
              to-world)))
    (setf (vx acc) 0.0)
    (nv+ vel acc)))

(defun desired-delta-velocity (hit velocity dt)
  (let ((limit 0.25))
    (flet ((acc (entity)
             (v. (v* (force entity) (inverse-mass entity) dt)
                 (hit-normal hit))))
      (let ((vx (vx velocity)))
        (- 0.0 vx (if (< (abs vx) limit)
                      0.0
                      (* (hit-restitution hit)
                         (- vx
                            (acc (hit-a hit))
                            (acc (hit-b hit))))))))))

(defun hit-to-contact (hit dt)
  (let* ((to-world (hit-basis hit))
         (a-relative (v- (hit-location hit) (location (hit-a hit))))
         (b-relative (v- (hit-location hit) (location (hit-b hit))))
         (velocity (nv- (local-velocity to-world (hit-a hit) a-relative dt)
                        (local-velocity to-world (hit-b hit) b-relative dt))))
    (make-contact :a (hit-a hit)
                  :b (hit-b hit)
                  :location (hit-location hit)
                  :normal (hit-normal hit)
                  :restitution (hit-restitution hit)
                  :friction (hit-friction hit)
                  :depth (hit-depth hit)
                  :to-world to-world
                  :velocity velocity
                  :desired-delta (desired-delta-velocity hit velocity dt)
                  :a-relative a-relative
                  :b-relative b-relative)))

(defun frictionless-impulse (contact &optional (impulse (vec3 0 0 0)))
  (flet ((body-delta-vel (loc body)
           (let ((delta-vel (vc loc (contact-normal contact))))
             (n*m (inverse-inertia-tensor body) delta-vel)
             (setf delta-vel (vc delta-vel (contact-a-relative contact)))
             (+ (inverse-mass body)
                (v. delta-vel (contact-normal contact))))))
    (vsetf impulse
           (/ (contact-desired-delta contact)
              (+ (body-delta-vel (contact-a-relative contact)
                                 (contact-a contact))
                 (body-delta-vel (contact-b-relative contact)
                                 (contact-b contact))))
           0.0
           0.0)))

(defun apply-velocity-change (contact)
  (let ((impulse (vec 0 0 0)))
    (declare (dynamic-extent impulse))
    (if (= 0 (contact-friction contact))
        (frictionless-impulse contact impulse)
        (error "Dew it."))
    (n*m (contact-to-world contact) impulse)
    (let ((torque (vc (contact-a-relative contact) impulse))
          (entity (contact-a contact)))
      (nv+ (rotation entity) (n*m (inverse-inertia-tensor entity) torque))
      (nv+* (velocity entity) impulse (inverse-mass entity)))
    ;; Second body needs to invert the direction.
    (let ((torque (vc impulse (contact-a-relative contact)))
          (entity (contact-a contact)))
      (nv+ (rotation entity) (n*m (inverse-inertia-tensor entity) torque))
      (nv+* (velocity entity) impulse (- (inverse-mass entity))))))

(defun apply-position-change (contact)
  )
