(in-package #:org.shirakumo.fraf.trial)

(defconstant MAX-CONTACTS 1024)

(defstruct contact-data
  (hits (map-into (make-array #.MAX-CONTACTS) #'make-hit) :type (simple-array T (#.MAX-CONTACTS)))
  (start 0 :type (integer 0 #.MAX-CONTACTS))
  (restitution 0.0 :type single-float)
  (friction 0.0 :type single-float))

(defgeneric detect-hits (a b contact-data))

(defmacro define-hit-detector ((a b &key (generate-inverse T)) &body body)
  `(progn
     (defmethod detect-hits ((a ,a) (b ,b) data)
       (let ((start (contact-data-start data))
             (hits (contact-data-hits data)))
         (when (<= #.MAX-CONTACTS start)
           (return-from detect-hits start))
         (let ((hit (aref hits start)))
           (block NIL
             (flet ((finish-hit ()
                      (setf (hit-restitution hit) (contact-data-restitution data))
                      (setf (hit-friction hit) (contact-data-friction data))
                      (setf (hit-a hit) (primitive-entity a))
                      (setf (hit-b hit) (primitive-entity b))
                      (incf start)
                      (if (< start #.MAX-CONTACTS)
                          (setf hit (aref hits start))
                          (return))))
               ,@body))
           (setf (contact-data-start data) start)
           data)))
     ,@(when (and generate-inverse
                  (not (eql a b)))
         `((defmethod detect-hits ((a ,b) (b ,a) data)
             (let ((start (contact-data-start data)))
               (detect-hits b a data)
               ;; FLEEP
               (loop with hits = (contact-data-hits data)
                     for i from start below (contact-data-start data)
                     for hit = (aref hits i)
                     do (rotatef (hit-a hit) (hit-b hit))
                        (nv- (hit-normal hit)))))))))

(defstruct primitive
  (entity NIL :type T)
  (transform (mat4) :type mat4))

(defmethod location ((primitive primitive))
  (n*m (primitive-transform primitive) (vec 0 0 0 1)))

(defstruct (sphere (:include primitive))
  (radius 1.0 :type single-float))

(defstruct (plane (:include primitive))
  (normal (vec3 0 1 0) :type vec3)
  (offset 0.0 :type single-float))

(defstruct (half-space (:include plane)))

(defstruct (box (:include primitive))
  (bsize (vec3 1 1 1) :type vec3))

(define-hit-detector (sphere sphere)
  (let* ((al (location a))
         (bl (location b))
         (dx (v- al bl))
         (len (vlength dx)))
    (when (and (<= (+ (sphere-radius a) (sphere-radius b)) len)
               (< 0 len))
      (v<- (hit-normal hit) dx)
      (nv/ (hit-normal hit) len)
      (v<- (hit-location hit) al)
      (nv+* (hit-location hit) dx 0.5)
      (setf (hit-depth hit) (- (+ (sphere-radius a) (sphere-radius b)) len))
      (finish-hit))))

(define-hit-detector (sphere half-space)
  (let* ((al (location a))
         (dist (- (v. (plane-normal b) al)
                  (sphere-radius a)
                  (plane-offset b))))
    (when (< dist 0)
      (v<- (hit-normal hit) (plane-normal b))
      (setf (hit-depth hit) (- dist))
      (v<- (hit-location hit) al)
      (nv+* (hit-location hit) (plane-normal b) (- (+ dist (sphere-radius a))))
      (finish-hit))))

(define-hit-detector (sphere plane)
  (let* ((al (location a))
         (dist (- (v. (plane-normal b) al)
                  (plane-offset b))))
    (when (< (* dist dist) (* (sphere-radius a) (sphere-radius a)))
      (v<- (hit-normal hit) (plane-normal b))
      (setf (hit-depth hit) (- dist))
      (when (< dist 0)
        (nv- (hit-normal hit))
        (setf (hit-depth hit) (- (hit-depth hit))))
      (incf (hit-depth hit) (sphere-radius a))
      (v<- (hit-location hit) al)
      (nv+* (hit-location hit) (plane-normal b) dist)
      (finish-hit))))

(define-hit-detector (box half-space)
  (let* ((bs (box-bsize a))
         (tf (box-transform a))
         (pd (plane-normal b))
         (po (plane-offset b))
         (a (vec3 (- (vx bs)) (- (vy bs)) (- (vz bs))))
         (b (vec3 (- (vx bs)) (- (vy bs)) (+ (vz bs))))
         (c (vec3 (- (vx bs)) (+ (vy bs)) (- (vz bs))))
         (d (vec3 (- (vx bs)) (+ (vy bs)) (+ (vz bs))))
         (e (vec3 (+ (vx bs)) (- (vy bs)) (- (vz bs))))
         (f (vec3 (+ (vx bs)) (- (vy bs)) (+ (vz bs))))
         (g (vec3 (+ (vx bs)) (+ (vy bs)) (- (vz bs))))
         (h (vec3 (+ (vx bs)) (+ (vy bs)) (+ (vz bs)))))
    (declare (dynamic-extent a b c d e f g h))
    (flet ((test (p)
             (n*m tf p)
             (let ((dist (v. p pd)))
               (when (<= dist po)
                 (v<- (hit-location hit) pd)
                 (nv* (hit-location hit) (- dist po))
                 (nv+ (hit-location hit) p)
                 (v<- (hit-location hit) pd)
                 (setf (hit-depth hit) (- po dist))
                 (finish-hit)))))
      (test a)
      (test b)
      (test c)
      (test d)
      (test e)
      (test f)
      (test g)
      (test h))))

(define-hit-detector (sphere box)
  )
